


<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> | </title>

        <link rel="stylesheet" href="/css/style.css">
        <link rel="stylesheet" href="/css/highlight.css">
        <link rel='stylesheet' href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='/jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter">

              
              <li>
                <a href="/about-this-book.html"> About This Book</a>
              </li>
                
              
              <li>
                <a href="/language.html"> Language Structure</a>
              </li>
                
                    <ul class="section">
                        
                          <li>
                            <a href="/language/keywords.html"> Keywords</a>
                          </li>
                        
                          <li>
                            <a href="/language/literals.html"> Literals</a>
                          </li>
                        
                          <li>
                            <a href="/language/variables-constants.html"> Variables and Constants</a>
                          </li>
                        
                          <li>
                            <a href="/language/assignment.html"> Assignment</a>
                          </li>
                        
                          <li>
                            <a href="/language/control-expressions.html"> Control Expressions</a>
                          </li>
                        
                          <li>
                            <a href="/language/methods-def.html"> Defining methods</a>
                          </li>
                        
                          <li>
                            <a href="/language/methods-call.html"> Calling methods</a>
                          </li>
                        
                          <li>
                            <a href="/language/modules-classes.html"> Modules and Classes</a>
                          </li>
                        
                          <li>
                            <a href="/language/exceptions.html"> Exceptions</a>
                          </li>
                        
                          <li>
                            <a href="/language/refinements.html"> Refinements</a>
                          </li>
                        
                          <li>
                            <a href="/language/precedence.html"> Precedence</a>
                          </li>
                        
                          <li>
                            <a href="/language/files.html"> File Structure</a>
                          </li>
                        
                          <li>
                            <a href="/language/globals.html"> Globals</a>
                          </li>
                        
                          <li>
                            <a href="/language/metaprogramming.html"> Metaprogramming</a>
                          </li>
                        
                    </ul>
                
              
              <li>
                <a href="/builtin.html"> Built-in Classes</a>
              </li>
                
                    <ul class="section">
                        
                          <li>
                            <a href="/builtin/core.html"> Language Core</a>
                          </li>
                        
                          <li>
                            <a href="/builtin/types.html"> Value Types</a>
                          </li>
                        
                          <li>
                            <a href="/builtin/errors-warnings.html"> Errors and Warnings</a>
                          </li>
                        
                          <li>
                            <a href="/builtin/system-cli.html"> System Programming and CLI</a>
                          </li>
                        
                          <li>
                            <a href="/builtin/concurrency-parallelism.html"> Concurrency and Parallelism</a>
                          </li>
                        
                          <li>
                            <a href="/builtin/internals.html"> Interpreter Internals</a>
                          </li>
                        
                          <li>
                            <a href="/builtin/marshal.html"> Marshal</a>
                          </li>
                        
                          <li>
                            <a href="/builtin/random.html"> Random</a>
                          </li>
                        
                    </ul>
                
              
              <li>
                <a href="/stdlib.html"> Standard Library</a>
              </li>
                
                    <ul class="section">
                        
                          <li>
                            <a href="/stdlib/patterns.html"> Design Patterns</a>
                          </li>
                        
                          <li>
                            <a href="/stdlib/formats.html"> Formats</a>
                          </li>
                        
                          <li>
                            <a href="/stdlib/development-debugging.html"> Development and Debugging</a>
                          </li>
                        
                          <li>
                            <a href="/stdlib/string-utilities.html"> String Utilities</a>
                          </li>
                        
                          <li>
                            <a href="/stdlib/networking-web.html"> Networking and Web</a>
                          </li>
                        
                          <li>
                            <a href="/stdlib/cli.html"> System Programming and CLI</a>
                          </li>
                        
                          <li>
                            <a href="/stdlib/cryptography-encoding.html"> Cryptography and Encoding</a>
                          </li>
                        
                          <li>
                            <a href="/stdlib/misc.html"> Miscellaneous Libraries</a>
                          </li>
                        
                    </ul>
                
              
              <li>
                <a href="/advanced-topics.html"> Advanced Topics</a>
              </li>
                
                    <ul class="section">
                        
                          <li>
                            <a href="/advanced-topics/third-party-libraries.html"> Third-Party Libraries</a>
                          </li>
                        
                          <li>
                            <a href="/advanced-topics/tools-approaches.html"> Tools and Approaches</a>
                          </li>
                        
                          <li>
                            <a href="/advanced-topics/contributing.html"> Contributing To Ruby</a>
                          </li>
                        
                    </ul>
                
              

            </ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                 <h1 id="creating-extension-libraries-for-ruby">Creating Extension Libraries for Ruby</h1>

<p>This document explains how to make extension libraries for Ruby.</p>

<h2 id="basic-knowledge">Basic Knowledge</h2>

<p>In C, variables have types and data do not have types. In contrast, Ruby
variables do not have a static type, and data themselves have types, so
data will need to be converted between the languages.</p>

<p>Data in Ruby are represented by the C type <code class="highlighter-rouge">VALUE</code>. Each VALUE data has
its data type.</p>

<p>To retrieve C data from a VALUE, you need to:</p>

<ol>
  <li>Identify the VALUE’s data type</li>
  <li>Convert the VALUE into C data</li>
</ol>

<p>Converting to the wrong data type may cause serious problems.</p>

<h3 id="data-types">Data Types</h3>

<p>The Ruby interpreter has the following data types:</p>

<ul>
  <li>T_NIL: nil</li>
  <li>T_OBJECT: ordinary object</li>
  <li>T_CLASS: class</li>
  <li>T_MODULE: module</li>
  <li>T_FLOAT: floating point number</li>
  <li>T_STRING: string</li>
  <li>T_REGEXP: regular expression</li>
  <li>T_ARRAY: array</li>
  <li>T_HASH: associative array</li>
  <li>T_STRUCT: (Ruby) structure</li>
  <li>T_BIGNUM: multi precision integer</li>
  <li>T_FIXNUM: Fixnum(31bit or 63bit integer)</li>
  <li>T_COMPLEX: complex number</li>
  <li>T_RATIONAL: rational number</li>
  <li>T_FILE: IO</li>
  <li>T_TRUE: true</li>
  <li>T_FALSE: false</li>
  <li>T_DATA: data</li>
  <li>T_SYMBOL: symbol</li>
</ul>

<p>In addition, there are several other types used internally:</p>

<ul>
  <li>T_ICLASS: included module</li>
  <li>T_MATCH: MatchData object</li>
  <li>T_UNDEF: undefined</li>
  <li>T_NODE: syntax tree node</li>
  <li>T_ZOMBIE: object awaiting finalization</li>
</ul>

<p>Most of the types are represented by C structures.</p>

<h3 id="check-data-type-of-the-value">Check Data Type of the VALUE</h3>

<p>The macro TYPE() defined in ruby.h shows the data type of the VALUE.
TYPE() returns the constant number T_XXXX described above. To handle
data types, your code will look something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch (TYPE(obj)) {
  case T_FIXNUM:
    /* process Fixnum */
    break;
  case T_STRING:
    /* process String */
    break;
  case T_ARRAY:
    /* process Array */
    break;
  default:
    /* raise exception */
    rb_raise(rb_eTypeError, "not valid value");
    break;
}
</code></pre></div></div>

<p>There is the data type check function</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Check_Type(VALUE value, int type)
</code></pre></div></div>

<p>which raises an exception if the VALUE does not have the type specified.</p>

<p>There are also faster check macros for fixnums and nil.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">FIXNUM_P</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="no">NIL_P</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="convert-value-into-c-data">Convert VALUE into C Data</h3>

<p>The data for type T_NIL, T_FALSE, T_TRUE are nil, false, true
respectively. They are singletons for the data type. The equivalent C
constants are: Qnil, Qfalse, Qtrue. Note that Qfalse is false in C also
(i.e. 0), but not Qnil.</p>

<p>The T_FIXNUM data is a 31bit or 63bit length fixed integer. This size
depends on the size of long: if long is 32bit then T_FIXNUM is 31bit,
if long is 64bit then T_FIXNUM is 63bit. T_FIXNUM can be converted to
a C integer by using the FIX2INT() macro or FIX2LONG(). Though you have
to check that the data is really FIXNUM before using them, they are
faster. FIX2LONG() never raises exceptions, but FIX2INT() raises
RangeError if the result is bigger or smaller than the size of int.
There are also NUM2INT() and NUM2LONG() which converts any Ruby numbers
into C integers. These macros include a type check, so an exception will
be raised if the conversion failed. NUM2DBL() can be used to retrieve
the double float value in the same way.</p>

<p>You can use the macros StringValue() and StringValuePtr() to get a
char* from a VALUE. StringValue(var) replaces var’s value with the
result of “var.to_str()”. StringValuePtr(var) does the same replacement
and returns the char* representation of var. These macros will skip the
replacement if var is a String. Notice that the macros take only the
lvalue as their argument, to change the value of var in place.</p>

<p>You can also use the macro named StringValueCStr(). This is just like
StringValuePtr(), but always adds a NUL character at the end of the
result. If the result contains a NUL character, this macro causes the
ArgumentError exception. StringValuePtr() doesn’t guarantee the
existence of a NUL at the end of the result, and the result may contain
NUL.</p>

<p>Other data types have corresponding C structures, e.g. struct RArray for
T_ARRAY etc. The VALUE of the type which has the corresponding
structure can be cast to retrieve the pointer to the struct. The casting
macro will be of the form RXXXX for each data type; for instance,
RARRAY(obj). See “ruby.h”. However, we do not recommend to access RXXXX
data directly because these data structures are complex. Use
corresponding rb_xxx() functions to access the internal struct. For
example, to access an entry of array, use rb_ary_entry(ary, offset)
and rb_ary_store(ary, offset, obj).</p>

<p>There are some accessing macros for structure members, for example
<code class="highlighter-rouge">RSTRING_LEN(str)</code> to get the size of the Ruby String object. The
allocated region can be accessed by <code class="highlighter-rouge">RSTRING_PTR(str)</code>.</p>

<p>Notice: Do not change the value of the structure directly, unless you
are responsible for the result. This ends up being the cause of
interesting bugs.</p>

<h3 id="convert-c-data-into-value">Convert C Data into VALUE</h3>

<p>To convert C data to Ruby values:</p>

<ul>
  <li>
    <p>FIXNUM: left shift 1 bit, and turn on its least significant bit (LSB).</p>
  </li>
  <li>
    <p>Other pointer values: cast to VALUE.</p>
  </li>
</ul>

<p>You can determine whether a VALUE is a pointer or not by checking its
LSB.</p>

<p>Notice: Ruby does not allow arbitrary pointer values to be a VALUE. They
should be pointers to the structures which Ruby knows about. The known
structures are defined in <ruby.h>.</ruby.h></p>

<p>To convert C numbers to Ruby values, use these macros:</p>

<ul>
  <li>INT2FIX(): for integers within 31bits.</li>
  <li>INT2NUM(): for arbitrary sized integers.</li>
</ul>

<p>INT2NUM() converts an integer into a Bignum if it is out of the FIXNUM
range, but is a bit slower.</p>

<h3 id="manipulating-ruby-data">Manipulating Ruby Data</h3>

<p>As I already mentioned, it is not recommended to modify an object’s
internal structure. To manipulate objects, use the functions supplied by
the Ruby interpreter. Some (not all) of the useful functions are listed
below:</p>

<h4 id="string-functions">String Functions</h4>

<ul>
  <li>rb_str_new(const char *ptr, long len): Creates a new Ruby string.</li>
</ul>

<p>rb_str_new2(const char *ptr)</p>

<ul>
  <li>
    <p>rb_str_new_cstr(const char *ptr): Creates a new Ruby string from a
C string. This is equivalent to rb_str_new(ptr, strlen(ptr)).</p>
  </li>
  <li>
    <p>rb_str_new_literal(const char *ptr): Creates a new Ruby string
from a C string literal.</p>
  </li>
  <li>
    <p>rb_tainted_str_new(const char *ptr, long len): Creates a new
tainted Ruby string. Strings from external data sources should be
tainted.</p>
  </li>
</ul>

<p>rb_tainted_str_new2(const char *ptr)</p>

<ul>
  <li>rb_tainted_str_new_cstr(const char *ptr): Creates a new tainted
Ruby string from a C string.</li>
</ul>

<p>rb_sprintf(const char *format, …)</p>

<ul>
  <li>
    <p>rb_vsprintf(const char *format, va_list ap): Creates a new Ruby
string with printf(3) format.</p>

    <p>Note: In the format string, “%”PRIsVALUE can be used for Object#to_s
(or Object#inspect if ‘+’ flag is set) output (and related argument
must be a VALUE). Since it conflicts with “%i”, for integers in format
strings, use “%d”.</p>
  </li>
  <li>
    <p>rb_str_append(VALUE str1, VALUE str2): Appends Ruby string str2 to
Ruby string str1.</p>
  </li>
  <li>
    <p>rb_str_cat(VALUE str, const char *ptr, long len): Appends len bytes
of data from ptr to the Ruby string.</p>
  </li>
</ul>

<p>rb_str_cat2(VALUE str, const char* ptr)</p>

<ul>
  <li>rb_str_cat_cstr(VALUE str, const char* ptr): Appends C string ptr
to Ruby string str. This function is equivalent to rb_str_cat(str,
ptr, strlen(ptr)).</li>
</ul>

<p>rb_str_catf(VALUE str, const char* format, …)</p>

<ul>
  <li>rb_str_vcatf(VALUE str, const char* format, va_list ap): Appends C
string format and successive arguments to Ruby string str according to
a printf-like format. These functions are equivalent to
rb_str_append(str, rb_sprintf(format, …)) and
rb_str_append(str, rb_vsprintf(format, ap)), respectively.</li>
</ul>

<p>rb_enc_str_new(const char *ptr, long len, rb_encoding *enc)</p>

<ul>
  <li>
    <p>rb_enc_str_new_cstr(const char *ptr, rb_encoding *enc): Creates
a new Ruby string with the specified encoding.</p>
  </li>
  <li>
    <p>rb_enc_str_new_literal(const char *ptr, rb_encoding *enc):
Creates a new Ruby string from a C string literal with the specified
encoding.</p>
  </li>
</ul>

<p>rb_usascii_str_new(const char *ptr, long len)</p>

<ul>
  <li>
    <p>rb_usascii_str_new_cstr(const char *ptr): Creates a new Ruby
string with encoding US-ASCII.</p>
  </li>
  <li>
    <p>rb_usascii_str_new_literal(const char *ptr): Creates a new Ruby
string from a C string literal with encoding US-ASCII.</p>
  </li>
</ul>

<p>rb_utf8_str_new(const char *ptr, long len)</p>

<ul>
  <li>
    <p>rb_utf8_str_new_cstr(const char *ptr): Creates a new Ruby string
with encoding UTF-8.</p>
  </li>
  <li>
    <p>rb_utf8_str_new_literal(const char *ptr): Creates a new Ruby
string from a C string literal with encoding UTF-8.</p>
  </li>
  <li>
    <p>rb_str_resize(VALUE str, long len): Resizes a Ruby string to len
bytes. If str is not modifiable, this function raises an exception.
The length of str must be set in advance. If len is less than the old
length the content beyond len bytes is discarded, else if len is
greater than the old length the content beyond the old length bytes
will not be preserved but will be garbage. Note that RSTRING_PTR(str)
may change by calling this function.</p>
  </li>
  <li>
    <p>rb_str_set_len(VALUE str, long len): Sets the length of a Ruby
string. If str is not modifiable, this function raises an exception.
This function preserves the content up to len bytes, regardless
RSTRING_LEN(str). len must not exceed the capacity of str.</p>
  </li>
</ul>

<h4 id="array-functions">Array Functions</h4>

<ul>
  <li>rb_ary_new(): Creates an array with no elements.</li>
</ul>

<p>rb_ary_new2(long len)</p>

<ul>
  <li>rb_ary_new_capa(long len): Creates an array with no elements,
allocating internal buffer for len elements.</li>
</ul>

<p>rb_ary_new3(long n, …)</p>

<ul>
  <li>rb_ary_new_from_args(long n, …): Creates an n-element array from
the arguments.</li>
</ul>

<p>rb_ary_new4(long n, VALUE *elts)</p>

<ul>
  <li>
    <p>rb_ary_new_from_values(long n, VALUE *elts): Creates an n-element
array from a C array.</p>
  </li>
  <li>
    <p>rb_ary_to_ary(VALUE obj): Converts the object into an array.
Equivalent to <code class="highlighter-rouge">Object#to_ary</code>.</p>
  </li>
</ul>

<p>There are many functions to operate an array. They may dump core if
other types are given.</p>

<ul>
  <li>
    <p>rb_ary_aref(int argc, const VALUE *argv, VALUE ary): Equivalent to
<code class="highlighter-rouge">Array#[]</code>.</p>
  </li>
  <li>
    <p>rb_ary_entry(VALUE ary, long offset): ary[offset]</p>
  </li>
  <li>
    <p>rb_ary_store(VALUE ary, long offset, VALUE obj): ary[offset] = obj</p>
  </li>
  <li>
    <p>rb_ary_subseq(VALUE ary, long beg, long len): ary[beg, len]</p>
  </li>
</ul>

<p>rb_ary_push(VALUE ary, VALUE val) rb_ary_pop(VALUE ary)
rb_ary_shift(VALUE ary)</p>

<ul>
  <li>
    <p>rb_ary_unshift(VALUE ary, VALUE val): ary.push, ary.pop, ary.shift,
ary.unshift</p>
  </li>
  <li>
    <p>rb_ary_cat(VALUE ary, const VALUE *ptr, long len): Appends len
elements of objects from ptr to the array.</p>
  </li>
</ul>

<h2 id="extending-ruby-with-c">Extending Ruby with C</h2>

<h3 id="adding-new-features-to-ruby">Adding New Features to Ruby</h3>

<p>You can add new features (classes, methods, etc.) to the Ruby
interpreter. Ruby provides APIs for defining the following things:</p>

<ul>
  <li>Classes, Modules</li>
  <li>Methods, Singleton Methods</li>
  <li>Constants</li>
</ul>

<h4 id="class-and-module-definition">Class and Module Definition</h4>

<p>To define a class or module, use the functions below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE rb_define_class(const char *name, VALUE super)
VALUE rb_define_module(const char *name)
</code></pre></div></div>

<p>These functions return the newly created class or module. You may want
to save this reference into a variable to use later.</p>

<p>To define nested classes or modules, use the functions below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE rb_define_class_under(VALUE outer, const char *name, VALUE super)
VALUE rb_define_module_under(VALUE outer, const char *name)
</code></pre></div></div>

<h4 id="method-and-singleton-method-definition">Method and Singleton Method Definition</h4>

<p>To define methods or singleton methods, use these functions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_method(VALUE klass, const char *name,
                      VALUE (*func)(ANYARGS), int argc)

void rb_define_singleton_method(VALUE object, const char *name,
                                VALUE (*func)(ANYARGS), int argc)
</code></pre></div></div>

<p>The <code class="highlighter-rouge">argc</code> represents the number of the arguments to the C function,
which must be less than 17. But I doubt you’ll need that many.</p>

<p>If <code class="highlighter-rouge">argc</code> is negative, it specifies the calling sequence, not number of
the arguments.</p>

<p>If argc is -1, the function will be called as:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE func(int argc, VALUE *argv, VALUE obj)
</code></pre></div></div>

<p>where argc is the actual number of arguments, argv is the C array of the
arguments, and obj is the receiver.</p>

<p>If argc is -2, the arguments are passed in a Ruby array. The function
will be called like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE func(VALUE obj, VALUE args)
</code></pre></div></div>

<p>where obj is the receiver, and args is the Ruby array containing actual
arguments.</p>

<p>There are some more functions to define methods. One takes an ID as the
name of method to be defined. See also ID or Symbol below.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_method_id(VALUE klass, ID name,
                         VALUE (*func)(ANYARGS), int argc)
</code></pre></div></div>

<p>There are two functions to define private/protected methods:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_private_method(VALUE klass, const char *name,
                              VALUE (*func)(ANYARGS), int argc)
void rb_define_protected_method(VALUE klass, const char *name,
                                VALUE (*func)(ANYARGS), int argc)
</code></pre></div></div>

<p>At last, rb_define_module_function defines a module function, which
are private AND singleton methods of the module. For example, sqrt is a
module function defined in the Math module. It can be called in the
following way:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p>or</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kp">include</span> <span class="no">Math</span>
<span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p>To define module functions, use:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_module_function(VALUE module, const char *name,
                               VALUE (*func)(ANYARGS), int argc)
</code></pre></div></div>

<p>In addition, function-like methods, which are private methods defined in
the Kernel module, can be defined using:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_global_function(const char *name, VALUE (*func)(ANYARGS), int argc)
</code></pre></div></div>

<p>To define an alias for the method,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_alias(VALUE module, const char* new, const char* old);
</code></pre></div></div>

<p>To define a reader/writer for an attribute,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_attr(VALUE klass, const char *name, int read, int write)
</code></pre></div></div>

<p>To define and undefine the <code class="highlighter-rouge">allocate</code> class method,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_alloc_func(VALUE klass, VALUE (*func)(VALUE klass));
void rb_undef_alloc_func(VALUE klass);
</code></pre></div></div>

<p>func has to take the klass as the argument and return a newly allocated
instance. This instance should be as empty as possible, without any
expensive (including external) resources.</p>

<p>If you are overriding an existing method of any ancestor of your class,
you may rely on:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE rb_call_super(int argc, const VALUE *argv)
</code></pre></div></div>

<p>To achieve the receiver of the current scope (if no other way is
available), you can use:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">VALUE</span> <span class="n">rb_current_receiver</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="constant-definition">Constant Definition</h4>

<p>We have 2 functions to define constants:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_const(VALUE klass, const char *name, VALUE val)
void rb_define_global_const(const char *name, VALUE val)
</code></pre></div></div>

<p>The former is to define a constant under specified class/module. The
latter is to define a global constant.</p>

<h3 id="use-ruby-features-from-c">Use Ruby Features from C</h3>

<p>There are several ways to invoke Ruby’s features from C code.</p>

<h4 id="evaluate-ruby-programs-in-a-string">Evaluate Ruby Programs in a String</h4>

<p>The easiest way to use Ruby’s functionality from a C program is to
evaluate the string as Ruby program. This function will do the job:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">VALUE</span> <span class="n">rb_eval_string</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</code></pre></div></div>

<p>Evaluation is done under the current context, thus current local
variables of the innermost method (which is defined by Ruby) can be
accessed.</p>

<p>Note that the evaluation can raise an exception. There is a safer
function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE rb_eval_string_protect(const char *str, int *state)
</code></pre></div></div>

<p>It returns nil when an error occurred. Moreover, *state is zero if str
was successfully evaluated, or nonzero otherwise.</p>

<h4 id="id-or-symbol">ID or Symbol</h4>

<p>You can invoke methods directly, without parsing the string. First I
need to explain about ID. ID is the integer number to represent Ruby’s
identifiers such as variable names. The Ruby data type corresponding to
ID is Symbol. It can be accessed from Ruby in the form:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">:Identifier</span>
</code></pre></div></div>

<p>or</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">:"any kind of string"</span>
</code></pre></div></div>

<p>You can get the ID value from a string within C code by using</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb_intern</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">name</span><span class="p">)</span>
<span class="n">rb_intern_str</span><span class="p">(</span><span class="no">VALUE</span> <span class="nb">name</span><span class="p">)</span>
</code></pre></div></div>

<p>You can retrieve ID from Ruby object (Symbol or String) given as an
argument by using</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rb_to_id(VALUE symbol)
rb_check_id(volatile VALUE *name)
rb_check_id_cstr(const char *name, long len, rb_encoding *enc)
</code></pre></div></div>

<p>These functions try to convert the argument to a String if it was not a
Symbol nor a String. The second function stores the converted result
into *name, and returns 0 if the string is not a known symbol. After
this function returned a non-zero value, *name is always a Symbol or a
String, otherwise it is a String if the result is 0. The third function
takes NUL-terminated C string, not Ruby VALUE.</p>

<p>You can retrieve Symbol from Ruby object (Symbol or String) given as an
argument by using</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rb_to_symbol(VALUE name)
rb_check_symbol(volatile VALUE *namep)
rb_check_symbol_cstr(const char *ptr, long len, rb_encoding *enc)
</code></pre></div></div>

<p>These functions are similar to above functions except that these return
a Symbol instead of an ID.</p>

<p>You can convert C ID to Ruby Symbol by using</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">VALUE</span> <span class="no">ID2SYM</span><span class="p">(</span><span class="no">ID</span> <span class="nb">id</span><span class="p">)</span>
</code></pre></div></div>

<p>and to convert Ruby Symbol object to ID, use</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ID</span> <span class="no">SYM2ID</span><span class="p">(</span><span class="no">VALUE</span> <span class="n">symbol</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="invoke-ruby-method-from-c">Invoke Ruby Method from C</h4>

<p>To invoke methods directly, you can use the function below</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE rb_funcall(VALUE recv, ID mid, int argc, ...)
</code></pre></div></div>

<p>This function invokes a method on the recv, with the method name
specified by the symbol mid.</p>

<h4 id="accessing-the-variables-and-constants">Accessing the Variables and Constants</h4>

<p>You can access class variables and instance variables using access
functions. Also, global variables can be shared between both
environments. There’s no way to access Ruby’s local variables.</p>

<p>The functions to access/modify instance variables are below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE rb_ivar_get(VALUE obj, ID id)
VALUE rb_ivar_set(VALUE obj, ID id, VALUE val)
</code></pre></div></div>

<p>id must be the symbol, which can be retrieved by rb_intern().</p>

<p>To access the constants of the class/module:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE rb_const_get(VALUE obj, ID id)
</code></pre></div></div>

<p>See also Constant Definition above.</p>

<h2 id="information-sharing-between-ruby-and-c">Information Sharing Between Ruby and C</h2>

<h3 id="ruby-constants-that-can-be-accessed-from-c">Ruby Constants That Can Be Accessed From C</h3>

<p>As stated in section 1.3, the following Ruby constants can be referred
from C.</p>

<p>Qtrue</p>

<ul>
  <li>
    <p>Qfalse: Boolean values. Qfalse is false in C also (i.e. 0).</p>
  </li>
  <li>
    <p>Qnil: Ruby nil in C scope.</p>
  </li>
</ul>

<h3 id="global-variables-shared-between-c-and-ruby">Global Variables Shared Between C and Ruby</h3>

<p>Information can be shared between the two environments using shared
global variables. To define them, you can use functions listed below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_variable(const char *name, VALUE *var)
</code></pre></div></div>

<p>This function defines the variable which is shared by both environments.
The value of the global variable pointed to by <code class="highlighter-rouge">var</code> can be accessed
through Ruby’s global variable named <code class="highlighter-rouge">name</code>.</p>

<p>You can define read-only (from Ruby, of course) variables using the
function below.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_readonly_variable(const char *name, VALUE *var)
</code></pre></div></div>

<p>You can define hooked variables. The accessor functions (getter and
setter) are called on access to the hooked variables.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_hooked_variable(const char *name, VALUE *var,
                               VALUE (*getter)(), void (*setter)())
</code></pre></div></div>

<p>If you need to supply either setter or getter, just supply 0 for the
hook you don’t need. If both hooks are 0, rb_define_hooked_variable()
works just like rb_define_variable().</p>

<p>The prototypes of the getter and setter functions are as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE (*getter)(ID id, VALUE *var);
void (*setter)(VALUE val, ID id, VALUE *var);
</code></pre></div></div>

<p>Also you can define a Ruby global variable without a corresponding C
variable. The value of the variable will be set/get only by hooks.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void rb_define_virtual_variable(const char *name,
                                VALUE (*getter)(), void (*setter)())
</code></pre></div></div>

<p>The prototypes of the getter and setter functions are as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE (*getter)(ID id);
void (*setter)(VALUE val, ID id);
</code></pre></div></div>

<h3 id="encapsulate-c-data-into-a-ruby-object">Encapsulate C Data into a Ruby Object</h3>

<p>Sometimes you need to expose your struct in the C world as a Ruby
object. In a situation like this, making use of the TypedData_XXX macro
family, the pointer to the struct and the Ruby object can be mutually
converted.</p>

<p>– The old (non-Typed) Data_XXX macro family has been deprecated. In
the future version of Ruby, it is possible old macros will not work. ++</p>

<h4 id="c-struct-to-ruby-object">C struct to Ruby object</h4>

<p>You can convert sval, a pointer to your struct, into a Ruby object with
the next macro.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sval</span><span class="p">)</span>
</code></pre></div></div>

<p>TypedData_Wrap_Struct() returns a created Ruby object as a VALUE.</p>

<p>The klass argument is the class for the object. data_type is a pointer
to a const rb_data_type_t which describes how Ruby should manage the
struct.</p>

<p>It is recommended that klass derives from a special class called Data
(rb_cData) but not from Object or other ordinal classes. If it doesn’t,
you have to call rb_undef_alloc_func(klass).</p>

<p>rb_data_type_t is defined like this. Let’s take a look at each member
of the struct.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct rb_data_type_struct rb_data_type_t;

struct rb_data_type_struct {
        const char *wrap_struct_name;
        struct {
                void (*dmark)(void*);
                void (*dfree)(void*);
                size_t (*dsize)(const void *);
                void *reserved[2];
        } function;
        const rb_data_type_t *parent;
        void *data;
        VALUE flags;
};
</code></pre></div></div>

<p>wrap_struct_name is an identifier of this instance of the struct. It
is basically used for collecting and emitting statistics. So the
identifier must be unique in the process, but doesn’t need to be valid
as a C or Ruby identifier.</p>

<p>These dmark / dfree functions are invoked during GC execution. No object
allocations are allowed during it, so do not allocate ruby objects
inside them.</p>

<p>dmark is a function to mark Ruby objects referred from your struct. It
must mark all references from your struct with rb_gc_mark or its
family if your struct keeps such references.</p>

<p>– Note that it is recommended to avoid such a reference. ++</p>

<p>dfree is a function to free the pointer allocation. If this is -1, the
pointer will be just freed.</p>

<p>dsize calculates memory consumption in bytes by the struct. Its
parameter is a pointer to your struct. You can pass 0 as dsize if it is
hard to implement such a function. But it is still recommended to avoid
0.</p>

<p>You have to fill reserved and parent with 0.</p>

<p>You can fill “data” with an arbitrary value for your use. Ruby does
nothing with the member.</p>

<p>flags is a bitwise-OR of the following flag values. Since they require
deep understanding of garbage collector in Ruby, you can just set 0 to
flags if you are not sure.</p>

<ul>
  <li>
    <p>RUBY_TYPED_FREE_IMMEDIATELY: This flag makes the garbage collector
immediately invoke dfree() during GC when it need to free your struct.
You can specify this flag if the dfree never unlocks Ruby’s internal
lock (GVL).</p>

    <p>If this flag is not set, Ruby defers invokation of dfree() and invokes
dfree() at the same time as finalizers.</p>
  </li>
  <li>
    <p>RUBY_TYPED_WB_PROTECTED: It shows that implementation of the object
supports write barriers. If this flag is set, Ruby is better able to
do garbage collection of the object.</p>

    <p>When it is set, however, you are responsible for putting write
barriers in all implementations of methods of that object as
appropriate. Otherwise Ruby might crash while running.</p>

    <p>More about write barriers can be found in “Generational GC” in
Appendix D.</p>
  </li>
</ul>

<p>You can allocate and wrap the structure in one step.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">TypedData_Make_Struct</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sval</span><span class="p">)</span>
</code></pre></div></div>

<p>This macro returns an allocated Data object, wrapping the pointer to the
structure, which is also allocated. This macro works like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">sval</span> <span class="o">=</span> <span class="no">ZALLOC</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="no">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sval</span><span class="p">))</span>
</code></pre></div></div>

<p>Arguments klass and data_type work like their counterparts in
TypedData_Wrap_Struct(). A pointer to the allocated structure will be
assigned to sval, which should be a pointer of the type specified.</p>

<h4 id="ruby-object-to-c-struct">Ruby object to C struct</h4>

<p>To retrieve the C pointer from the Data object, use the macro
Data_Get_Struct().</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TypedData_Get_Struct(obj, type, &amp;data_type, sval)
</code></pre></div></div>

<p>A pointer to the structure will be assigned to the variable sval.</p>

<p>See the example below for details.</p>

<h2 id="example---creating-the-dbm-extension">Example - Creating the dbm Extension</h2>

<p>OK, here’s the example of making an extension library. This is the
extension to access DBMs. The full source is included in the ext/
directory in the Ruby’s source tree.</p>

<h3 id="make-the-directory">Make the Directory</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% mkdir ext/dbm
</code></pre></div></div>

<p>Make a directory for the extension library under ext directory.</p>

<h3 id="design-the-library">Design the Library</h3>

<p>You need to design the library features, before making it.</p>

<h3 id="write-the-c-code">Write the C Code</h3>

<p>You need to write C code for your extension library. If your library has
only one source file, choosing <code class="highlighter-rouge">LIBRARY.c`' as a file name is
preferred.  On the
other hand, in case your library has multiple source files, avoid
choosing
</code>LIBRARY.c<code class="highlighter-rouge">' for a file name.  It may conflict with an intermediate
file
</code><code class="highlighter-rouge">LIBRARY.o</code>’ on some platforms. Note that some functions in mkmf
library described below generate a file <code class="highlighter-rouge">conftest.c`' for checking
with compilation. 
You shouldn't choose</code>conftest.c`’ as a name of a source file.</p>

<p>Ruby will execute the initializing function named <code class="highlighter-rouge">Init_LIBRARY`' in
the
library.  For example,</code>Init_dbm()`’ will be executed when loading
the library.</p>

<p>Here’s the example of an initializing function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void
Init_dbm(void)
{
    /* define DBM class */
    VALUE cDBM = rb_define_class("DBM", rb_cObject);
    /* DBM includes Enumerable module */
    rb_include_module(cDBM, rb_mEnumerable);

    /* DBM has class method open(): arguments are received as C array */
    rb_define_singleton_method(cDBM, "open", fdbm_s_open, -1);

    /* DBM instance method close(): no args */
    rb_define_method(cDBM, "close", fdbm_close, 0);
    /* DBM instance method []: 1 argument */
    rb_define_method(cDBM, "[]", fdbm_fetch, 1);

    /* ... */

    /* ID for a instance variable to store DBM data */
    id_dbm = rb_intern("dbm");
}
</code></pre></div></div>

<p>The dbm extension wraps the dbm struct in the C environment using
TypedData_Make_Struct.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct dbmdata {
    int  di_size;
    DBM *di_dbm;
};

static const rb_data_type_t dbm_type = {
    "dbm",
    {0, free_dbm, memsize_dbm,},
    0, 0,
    RUBY_TYPED_FREE_IMMEDIATELY,
};

obj = TypedData_Make_Struct(klass, struct dbmdata, &amp;dbm_type, dbmp);
</code></pre></div></div>

<p>This code wraps the dbmdata structure into a Ruby object. We avoid
wrapping DBM* directly, because we want to cache size information.</p>

<p>To retrieve the dbmdata structure from a Ruby object, we define the
following macro:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\#define GetDBM(obj, dbmp) do {\
    TypedData_Get_Struct((obj), struct dbmdata, &amp;dbm_type, (dbmp));\
    if ((dbmp) == 0) closed_dbm();\
    if ((dbmp)-&gt;di_dbm == 0) closed_dbm();\
} while (0)
</code></pre></div></div>

<p>This sort of complicated macro does the retrieving and close checking
for the DBM.</p>

<p>There are three kinds of way to receive method arguments. First, methods
with a fixed number of arguments receive arguments like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static VALUE
fdbm_delete(VALUE obj, VALUE keystr)
{
      /* ... */
}
</code></pre></div></div>

<p>The first argument of the C function is the self, the rest are the
arguments to the method.</p>

<p>Second, methods with an arbitrary number of arguments receive arguments
like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static VALUE
fdbm_s_open(int argc, VALUE *argv, VALUE klass)
{
    /* ... */
    if (rb_scan_args(argc, argv, "11", &amp;file, &amp;vmode) == 1) {
        mode = 0666;          /* default value */
    }
    /* ... */
}
</code></pre></div></div>

<p>The first argument is the number of method arguments, the second
argument is the C array of the method arguments, and the third argument
is the receiver of the method.</p>

<p>You can use the function rb_scan_args() to check and retrieve the
arguments. The third argument is a string that specifies how to capture
method arguments and assign them to the following VALUE references.</p>

<p>You can just check the argument number with rb_check_arity(), this is
handy in the case you want to treat the arguments as a list.</p>

<p>The following is an example of a method that takes arguments by Ruby’s
array:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static VALUE
thread_initialize(VALUE thread, VALUE args)
{
    /* ... */
}
</code></pre></div></div>

<p>The first argument is the receiver, the second one is the Ruby array
which contains the arguments to the method.</p>

<p><strong>Notice</strong>: GC should know about global variables which refer to Ruby’s
objects, but are not exported to the Ruby world. You need to protect
them by</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">void</span> <span class="n">rb_global_variable</span><span class="p">(</span><span class="no">VALUE</span> <span class="o">*</span><span class="n">var</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="prepare-extconfrb">Prepare extconf.rb</h3>

<p>If the file named extconf.rb exists, it will be executed to generate
Makefile.</p>

<p>extconf.rb is the file for checking compilation conditions etc. You need
to put</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'mkmf'</span>
</code></pre></div></div>

<p>at the top of the file. You can use the functions below to check various
conditions.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>have_macro(macro[, headers[, opt]]): check whether macro is defined
have_library(lib[, func[, headers[, opt]]]): check whether library containing function exists
find_library(lib[, func, *paths]): find library from paths
have_func(func[, headers[, opt]): check whether function exists
have_var(var[, headers[, opt]]): check whether variable exists
have_header(header[, preheaders[, opt]]): check whether header file exists
find_header(header, *paths): find header from paths
have_framework(fw): check whether framework exists (for MacOS X)
have_struct_member(type, member[, headers[, opt]]): check whether struct has member
have_type(type[, headers[, opt]]): check whether type exists
find_type(type, opt, *headers): check whether type exists in headers
have_const(const[, headers[, opt]]): check whether constant is defined
check_sizeof(type[, headers[, opts]]): check size of type
check_signedness(type[, headers[, opts]]): check signedness of type
convertible_int(type[, headers[, opts]]): find convertible integer type
find_executable(bin[, path]): find executable file path
create_header(header): generate configured header
create_makefile(target[, target_prefix]): generate Makefile
</code></pre></div></div>

<p>See MakeMakefile for full documentation of these functions.</p>

<p>The value of the variables below will affect the Makefile.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$CFLAGS: included in CFLAGS make variable (such as -O)
$CPPFLAGS: included in CPPFLAGS make variable (such as -I, -D)
$LDFLAGS: included in LDFLAGS make variable (such as -L)
$objs: list of object file names
</code></pre></div></div>

<p>Normally, the object files list is automatically generated by searching
source files, but you must define them explicitly if any sources will be
generated while building.</p>

<p>If a compilation condition is not fulfilled, you should not call
``create_makefile`’. The Makefile will not be generated, compilation
will not be done.</p>

<h3 id="prepare-depend-optional">Prepare Depend (Optional)</h3>

<p>If the file named depend exists, Makefile will include that file to
check dependencies. You can make this file by invoking</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% gcc -MM *.c &gt; depend
</code></pre></div></div>

<p>It’s harmless. Prepare it.</p>

<h3 id="generate-makefile">Generate Makefile</h3>

<p>Try generating the Makefile by:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ruby</span> <span class="n">extconf</span><span class="p">.</span><span class="nf">rb</span>
</code></pre></div></div>

<p>If the library should be installed under vendor_ruby directory instead
of site_ruby directory, use –vendor option as follows.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ruby</span> <span class="n">extconf</span><span class="p">.</span><span class="nf">rb</span> <span class="o">--</span><span class="n">vendor</span>
</code></pre></div></div>

<p>You don’t need this step if you put the extension library under the ext
directory of the ruby source tree. In that case, compilation of the
interpreter will do this step for you.</p>

<h3 id="run-make">Run make</h3>

<p>Type</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">make</span>
</code></pre></div></div>

<p>to compile your extension. You don’t need this step either if you have
put the extension library under the ext directory of the ruby source
tree.</p>

<h3 id="debug">Debug</h3>

<p>You may need to rb_debug the extension. Extensions can be linked
statically by adding the directory name in the ext/Setup file so that
you can inspect the extension with the debugger.</p>

<h3 id="done-now-you-have-the-extension-library">Done! Now You Have the Extension Library</h3>

<p>You can do anything you want with your library. The author of Ruby will
not claim any restrictions on your code depending on the Ruby API. Feel
free to use, modify, distribute or sell your program.</p>

<h2 id="appendix-a-ruby-source-files-overview">Appendix A. Ruby Source Files Overview</h2>

<h3 id="ruby-language-core">Ruby Language Core</h3>

<ul>
  <li>class.c: classes and modules</li>
  <li>error.c: exception classes and exception mechanism</li>
  <li>gc.c: memory management</li>
  <li>load.c: library loading</li>
  <li>object.c: objects</li>
  <li>variable.c: variables and constants</li>
</ul>

<h3 id="ruby-syntax-parser">Ruby Syntax Parser</h3>

<ul>
  <li>parse.y: grammar definition</li>
  <li>parse.c: automatically generated from parse.y</li>
  <li>defs/keywords: reserved keywords</li>
  <li>lex.c: automatically generated from keywords</li>
</ul>

<h3 id="ruby-evaluator-aka-yarv">Ruby Evaluator (a.k.a. YARV)</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>compile.c
eval.c
eval_error.c
eval_jump.c
eval_safe.c
insns.def           : definition of VM instructions
iseq.c              : implementation of VM::ISeq
thread.c            : thread management and context switching
thread_win32.c      : thread implementation
thread_pthread.c    : ditto
vm.c
vm_dump.c
vm_eval.c
vm_exec.c
vm_insnhelper.c
vm_method.c

defs/opt_insns_unif.def  : instruction unification
defs/opt_operand.def     : definitions for optimization

  -&gt; insn*.inc           : automatically generated
  -&gt; opt*.inc            : automatically generated
  -&gt; vm.inc              : automatically generated
</code></pre></div></div>

<h3 id="regular-expression-engine-oniguruma">Regular Expression Engine (Oniguruma)</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">regex</span><span class="p">.</span><span class="nf">c</span>
<span class="n">regcomp</span><span class="p">.</span><span class="nf">c</span>
<span class="n">regenc</span><span class="p">.</span><span class="nf">c</span>
<span class="n">regerror</span><span class="p">.</span><span class="nf">c</span>
<span class="n">regexec</span><span class="p">.</span><span class="nf">c</span>
<span class="n">regparse</span><span class="p">.</span><span class="nf">c</span>
<span class="n">regsyntax</span><span class="p">.</span><span class="nf">c</span>
</code></pre></div></div>

<h3 id="utility-functions">Utility Functions</h3>

<ul>
  <li>debug.c: debug symbols for C debugger</li>
  <li>dln.c: dynamic loading</li>
  <li>st.c: general purpose hash table</li>
  <li>strftime.c: formatting times</li>
  <li>util.c: misc utilities</li>
</ul>

<h3 id="ruby-interpreter-implementation">Ruby Interpreter Implementation</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dmyext</span><span class="p">.</span><span class="nf">c</span>
<span class="n">dmydln</span><span class="p">.</span><span class="nf">c</span>
<span class="n">dmyencoding</span><span class="p">.</span><span class="nf">c</span>
<span class="nb">id</span><span class="p">.</span><span class="nf">c</span>
<span class="n">inits</span><span class="p">.</span><span class="nf">c</span>
<span class="n">main</span><span class="p">.</span><span class="nf">c</span>
<span class="n">ruby</span><span class="p">.</span><span class="nf">c</span>
<span class="n">version</span><span class="p">.</span><span class="nf">c</span>

<span class="n">gem_prelude</span><span class="p">.</span><span class="nf">rb</span>
<span class="n">prelude</span><span class="p">.</span><span class="nf">rb</span>
</code></pre></div></div>

<h3 id="class-library">Class Library</h3>

<ul>
  <li>array.c: Array</li>
  <li>bignum.c: Bignum</li>
  <li>compar.c: Comparable</li>
  <li>complex.c: Complex</li>
  <li>cont.c: Fiber, Continuation</li>
  <li>dir.c: Dir</li>
  <li>enum.c: Enumerable</li>
  <li>enumerator.c: Enumerator</li>
  <li>file.c: File</li>
  <li>hash.c: Hash</li>
  <li>io.c: IO</li>
  <li>marshal.c: Marshal</li>
  <li>math.c: Math</li>
  <li>numeric.c: Numeric, Integer, Fixnum, Float</li>
  <li>pack.c: <code class="highlighter-rouge">Array#pack</code>, <code class="highlighter-rouge">String#unpack</code></li>
  <li>proc.c: Binding, Proc</li>
  <li>process.c: Process</li>
  <li>random.c: random number</li>
  <li>range.c: Range</li>
  <li>rational.c: Rational</li>
  <li>re.c: Regexp, MatchData</li>
  <li>signal.c: Signal</li>
  <li>sprintf.c: <code class="highlighter-rouge">String#sprintf</code></li>
  <li>string.c: String</li>
  <li>struct.c: Struct</li>
  <li>
    <p>time.c: Time</p>
  </li>
  <li>defs/known_errors.def: Errno::* exception classes</li>
  <li>-&gt; known_errors.inc: automatically generated</li>
</ul>

<h3 id="multilingualization">Multilingualization</h3>

<ul>
  <li>encoding.c: Encoding</li>
  <li>transcode.c: Encoding::Converter</li>
  <li>enc/*.c: encoding classes</li>
  <li>enc/trans/*: codepoint mapping tables</li>
</ul>

<h3 id="goruby-interpreter-implementation">goruby Interpreter Implementation</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goruby.c
golf_prelude.rb     : goruby specific libraries.
  -&gt; golf_prelude.c : automatically generated
</code></pre></div></div>

<h2 id="appendix-b-ruby-extension-api-reference">Appendix B. Ruby Extension API Reference</h2>

<h3 id="types">Types</h3>

<ul>
  <li>VALUE: The type for the Ruby object. Actual structures are defined in
ruby.h, such as struct RString, etc. To refer the values in
structures, use casting macros like RSTRING(obj).</li>
</ul>

<h3 id="variables-and-constants">Variables and Constants</h3>

<ul>
  <li>
    <p>Qnil: nil object</p>
  </li>
  <li>
    <p>Qtrue: true object (default true value)</p>
  </li>
  <li>
    <p>Qfalse: false object</p>
  </li>
</ul>

<h3 id="c-pointer-wrapping">C Pointer Wrapping</h3>

<ul>
  <li>
    <p>Data_Wrap_Struct(VALUE klass, void (<em>mark)(), void (</em>free)(), void
*sval): Wrap a C pointer into a Ruby object. If object has references
to other Ruby objects, they should be marked by using the mark
function during the GC process. Otherwise, mark should be 0. When this
object is no longer referred by anywhere, the pointer will be
discarded by free function.</p>
  </li>
  <li>
    <p>Data_Make_Struct(klass, type, mark, free, sval): This macro
allocates memory using malloc(), assigns it to the variable sval, and
returns the DATA encapsulating the pointer to memory region.</p>
  </li>
  <li>
    <p>Data_Get_Struct(data, type, sval): This macro retrieves the pointer
value from DATA, and assigns it to the variable sval.</p>
  </li>
</ul>

<h3 id="checking-data-types">Checking Data Types</h3>

<ul>
  <li>
    <p>RB_TYPE_P(value, type): Is <code class="highlighter-rouge">value</code> an internal type (T_NIL,
T_FIXNUM, etc.)?</p>
  </li>
  <li>
    <p>TYPE(value): Internal type (T_NIL, T_FIXNUM, etc.)</p>
  </li>
  <li>
    <p>FIXNUM_P(value): Is <code class="highlighter-rouge">value</code> a Fixnum?</p>
  </li>
  <li>
    <p>NIL_P(value): Is <code class="highlighter-rouge">value</code> nil?</p>
  </li>
  <li>
    <p>RB_INTEGER_TYPE_P(value): Is <code class="highlighter-rouge">value</code> an Integer?</p>
  </li>
  <li>
    <p>RB_FLOAT_TYPE_P(value): Is <code class="highlighter-rouge">value</code> a Float?</p>
  </li>
  <li>
    <p>void Check_Type(VALUE value, int type): Ensures <code class="highlighter-rouge">value</code> is of the
given internal <code class="highlighter-rouge">type</code> or raises a TypeError</p>
  </li>
  <li>
    <p>SafeStringValue(value): Checks that <code class="highlighter-rouge">value</code> is a String and is not
tainted</p>
  </li>
</ul>

<h3 id="data-type-conversion">Data Type Conversion</h3>

<ul>
  <li>
    <p>FIX2INT(value), INT2FIX(i): Fixnum &lt;-&gt; integer</p>
  </li>
  <li>
    <p>FIX2LONG(value), LONG2FIX(l): Fixnum &lt;-&gt; long</p>
  </li>
  <li>
    <p>NUM2INT(value), INT2NUM(i): Numeric &lt;-&gt; integer</p>
  </li>
  <li>
    <p>NUM2UINT(value), UINT2NUM(ui): Numeric &lt;-&gt; unsigned integer</p>
  </li>
  <li>
    <p>NUM2LONG(value), LONG2NUM(l): Numeric &lt;-&gt; long</p>
  </li>
  <li>
    <p>NUM2ULONG(value), ULONG2NUM(ul): Numeric &lt;-&gt; unsigned long</p>
  </li>
  <li>
    <p>NUM2LL(value), LL2NUM(ll): Numeric &lt;-&gt; long long</p>
  </li>
  <li>
    <p>NUM2ULL(value), ULL2NUM(ull): Numeric &lt;-&gt; unsigned long long</p>
  </li>
  <li>
    <p>NUM2OFFT(value), OFFT2NUM(off): Numeric &lt;-&gt; off_t</p>
  </li>
  <li>
    <p>NUM2SIZET(value), SIZET2NUM(size): Numeric &lt;-&gt; size_t</p>
  </li>
  <li>
    <p>NUM2SSIZET(value), SSIZET2NUM(ssize): Numeric &lt;-&gt; ssize_t</p>
  </li>
  <li>
    <p>rb_integer_pack(value, words, numwords, wordsize, nails, flags),
rb_integer_unpack(words, numwords, wordsize, nails, flags): Numeric
&lt;-&gt; Arbitrary size integer buffer</p>
  </li>
  <li>
    <p>NUM2DBL(value): Numeric -&gt; double</p>
  </li>
  <li>
    <p>rb_float_new(f): double -&gt; Float</p>
  </li>
  <li>
    <p>RSTRING_LEN(str): String -&gt; length of String data in bytes</p>
  </li>
  <li>
    <p>RSTRING_PTR(str): String -&gt; pointer to String data Note that the
result pointer may not be NUL-terminated</p>
  </li>
  <li>
    <p>StringValue(value): Object with <code class="highlighter-rouge">#to_str</code> -&gt; String</p>
  </li>
  <li>
    <p>StringValuePtr(value): Object with <code class="highlighter-rouge">#to_str</code> -&gt; pointer to String data</p>
  </li>
  <li>
    <p>StringValueCStr(value): Object with <code class="highlighter-rouge">#to_str</code> -&gt; pointer to String
data without NUL bytes It is guaranteed that the result data is
NUL-terminated</p>
  </li>
  <li>
    <p>rb_str_new2(s): char * -&gt; String</p>
  </li>
</ul>

<h3 id="defining-classes-and-modules">Defining Classes and Modules</h3>

<ul>
  <li>
    <p>VALUE rb_define_class(const char *name, VALUE super): Defines a new
Ruby class as a subclass of super.</p>
  </li>
  <li>
    <p>VALUE rb_define_class_under(VALUE module, const char *name, VALUE
super): Creates a new Ruby class as a subclass of super, under the
module’s namespace.</p>
  </li>
  <li>
    <p>VALUE rb_define_module(const char *name): Defines a new Ruby
module.</p>
  </li>
  <li>
    <p>VALUE rb_define_module_under(VALUE module, const char *name):
Defines a new Ruby module under the module’s namespace.</p>
  </li>
  <li>
    <p>void rb_include_module(VALUE klass, VALUE module): Includes module
into class. If class already includes it, just ignored.</p>
  </li>
  <li>
    <p>void rb_extend_object(VALUE object, VALUE module): Extend the object
with the module’s attributes.</p>
  </li>
</ul>

<h3 id="defining-global-variables">Defining Global Variables</h3>

<ul>
  <li>
    <p>void rb_define_variable(const char *name, VALUE *var): Defines a
global variable which is shared between C and Ruby. If name contains a
character which is not allowed to be part of the symbol, it can’t be
seen from Ruby programs.</p>
  </li>
  <li>
    <p>void rb_define_readonly_variable(const char *name, VALUE *var):
Defines a read-only global variable. Works just like
rb_define_variable(), except the defined variable is read-only.</p>
  </li>
  <li>
    <p>void rb_define_virtual_variable(const char <em>name, VALUE
(</em>getter)(), void (*setter)()): Defines a virtual variable, whose
behavior is defined by a pair of C functions. The getter function is
called when the variable is referenced. The setter function is called
when the variable is set to a value. The prototype for getter/setter
functions are:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  VALUE getter(ID id)
  void setter(VALUE val, ID id)
</code></pre></div>    </div>

    <p>The getter function must return the value for the access.</p>
  </li>
  <li>
    <p>void rb_define_hooked_variable(const char <em>name, VALUE *var, VALUE
(</em>getter)(), void (*setter)()): Defines hooked variable. It’s a
virtual variable with a C variable. The getter is called as</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  VALUE getter(ID id, VALUE *var)
</code></pre></div>    </div>

    <p>returning a new value. The setter is called as</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  void setter(VALUE val, ID id, VALUE *var)
</code></pre></div>    </div>
  </li>
  <li>
    <p>void rb_global_variable(VALUE *var): GC requires C global variables
which hold Ruby values to be marked. rb_global_variable tells GC to
protect these variables.</p>
  </li>
</ul>

<h3 id="constant-definition-1">Constant Definition</h3>

<ul>
  <li>
    <p>void rb_define_const(VALUE klass, const char *name, VALUE val):
Defines a new constant under the class/module.</p>
  </li>
  <li>
    <p>void rb_define_global_const(const char *name, VALUE val): Defines
a global constant. This is just the same as</p>

    <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">rb_define_const</span><span class="p">(</span><span class="n">rb_cObject</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="method-definition">Method Definition</h3>

<ul>
  <li>
    <p>rb_define_method(VALUE klass, const char <em>name, VALUE
(</em>func)(ANYARGS), int argc): Defines a method for the class. func is
the function pointer. argc is the number of arguments. if argc is -1,
the function will receive 3 arguments: argc, argv, and self. if argc
is -2, the function will receive 2 arguments, self and args, where
args is a Ruby array of the method arguments.</p>
  </li>
  <li>
    <p>rb_define_private_method(VALUE klass, const char <em>name, VALUE
(</em>func)(ANYARGS), int argc): Defines a private method for the class.
Arguments are same as rb_define_method().</p>
  </li>
  <li>
    <p>rb_define_singleton_method(VALUE klass, const char <em>name, VALUE
(</em>func)(ANYARGS), int argc): Defines a singleton method. Arguments are
same as rb_define_method().</p>
  </li>
  <li>
    <p>rb_check_arity(int argc, int min, int max): Check the number of
arguments, argc is in the range of min..max. If max is
UNLIMITED_ARGUMENTS, upper bound is not checked. If argc is out of
bounds, an ArgumentError will be raised.</p>
  </li>
  <li>
    <p>rb_scan_args(int argc, VALUE *argv, const char *fmt, …):
Retrieve argument from argc and argv to given VALUE references
according to the format string. The format can be described in ABNF as
follows:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  scan-arg-spec  := param-arg-spec [option-hash-arg-spec] [block-arg-spec]
  
  param-arg-spec := pre-arg-spec [post-arg-spec] / post-arg-spec /
                    pre-opt-post-arg-spec
  pre-arg-spec   := num-of-leading-mandatory-args [num-of-optional-args]
  post-arg-spec  := sym-for-variable-length-args
                    [num-of-trailing-mandatory-args]
  pre-opt-post-arg-spec := num-of-leading-mandatory-args num-of-optional-args
                           num-of-trailing-mandatory-args
  option-hash-arg-spec := sym-for-option-hash-arg
  block-arg-spec := sym-for-block-arg
  
  num-of-leading-mandatory-args  := DIGIT ; The number of leading
                                          ; mandatory arguments
  num-of-optional-args           := DIGIT ; The number of optional
                                          ; arguments
  sym-for-variable-length-args   := "*"   ; Indicates that variable
                                          ; length arguments are
                                          ; captured as a ruby array
  num-of-trailing-mandatory-args := DIGIT ; The number of trailing
                                          ; mandatory arguments
  sym-for-option-hash-arg        := ":"   ; Indicates that an option
                                          ; hash is captured if the last
                                          ; argument is a hash or can be
                                          ; converted to a hash with
                                          ; #to_hash.  When the last
                                          ; argument is nil, it is
                                          ; captured if it is not
                                          ; ambiguous to take it as
                                          ; empty option hash; i.e. '*'
                                          ; is not specified and
                                          ; arguments are given more
                                          ; than sufficient.
  sym-for-block-arg              := "&amp;"   ; Indicates that an iterator
                                          ; block should be captured if
                                          ; given
</code></pre></div>    </div>

    <p>For example, “12” means that the method requires at least one
argument, and at most receives three (1+2) arguments. So, the format
string must be followed by three variable references, which are to be
assigned to captured arguments. For omitted arguments, variables are
set to Qnil. NULL can be put in place of a variable reference, which
means the corresponding captured argument(s) should be just dropped.</p>

    <p>The number of given arguments, excluding an option hash or iterator
block, is returned.</p>
  </li>
  <li>
    <p>int rb_get_kwargs(VALUE keyword_hash, const ID *table, int
required, int optional, VALUE *values): Retrieves argument VALUEs
bound to keywords, which directed by <code class="highlighter-rouge">table</code> into <code class="highlighter-rouge">values</code>, deleting
retrieved entries from <code class="highlighter-rouge">keyword_hash</code> along the way. First <code class="highlighter-rouge">required</code>
number of IDs referred by <code class="highlighter-rouge">table</code> are mandatory, and succeeding
<code class="highlighter-rouge">optional</code> (- <code class="highlighter-rouge">optional</code> - 1 if <code class="highlighter-rouge">optional</code> is negative) number of IDs
are optional. If a mandatory key is not contained in <code class="highlighter-rouge">keyword_hash</code>,
raises “missing keyword” <code class="highlighter-rouge">ArgumentError</code>. If an optional key is not
present in <code class="highlighter-rouge">keyword_hash</code>, the corresponding element in <code class="highlighter-rouge">values</code> is
set to <code class="highlighter-rouge">Qundef</code>. If <code class="highlighter-rouge">optional</code> is negative, rest of <code class="highlighter-rouge">keyword_hash</code> are
ignored, otherwise raises “unknown keyword” <code class="highlighter-rouge">ArgumentError</code>.</p>

    <p>Be warned, handling keyword arguments in the C API is less efficient
than handling them in Ruby. Consider using a Ruby wrapper method
around a non-keyword C function. ref:
https://bugs.ruby-lang.org/issues/11339</p>
  </li>
  <li>
    <p>VALUE rb_extract_keywords(VALUE *original_hash): Extracts pairs
whose key is a symbol into a new hash from a hash object referred by
<code class="highlighter-rouge">original_hash</code>. If the original hash contains non-symbol keys, then
they are copied to another hash and the new hash is stored through
<code class="highlighter-rouge">original_hash</code>, else 0 is stored.</p>
  </li>
</ul>

<h3 id="invoking-ruby-method">Invoking Ruby method</h3>

<ul>
  <li>VALUE rb_funcall(VALUE recv, ID mid, int narg, …): Invokes a
method. To retrieve mid from a method name, use rb_intern(). Able to
call even private/protected methods.</li>
</ul>

<p>VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)</p>

<ul>
  <li>
    <p>VALUE rb_funcallv(VALUE recv, ID mid, int argc, VALUE *argv):
Invokes a method, passing arguments as an array of values. Able to
call even private/protected methods.</p>
  </li>
  <li>
    <p>VALUE rb_funcallv_public(VALUE recv, ID mid, int argc, VALUE
*argv): Invokes a method, passing arguments as an array of values.
Able to call only public methods.</p>
  </li>
  <li>
    <p>VALUE rb_eval_string(const char *str): Compiles and executes the
string as a Ruby program.</p>
  </li>
  <li>
    <p>ID rb_intern(const char *name): Returns ID corresponding to the
name.</p>
  </li>
  <li>
    <p>char *rb_id2name(ID id): Returns the name corresponding ID.</p>
  </li>
  <li>
    <p>char *rb_class2name(VALUE klass): Returns the name of the class.</p>
  </li>
  <li>
    <p>int rb_respond_to(VALUE obj, ID id): Returns true if the object
responds to the message specified by id.</p>
  </li>
</ul>

<h3 id="instance-variables">Instance Variables</h3>

<ul>
  <li>
    <p>VALUE rb_iv_get(VALUE obj, const char *name): Retrieve the value of
the instance variable. If the name is not prefixed by `@’, that
variable shall be inaccessible from Ruby.</p>
  </li>
  <li>
    <p>VALUE rb_iv_set(VALUE obj, const char *name, VALUE val): Sets the
value of the instance variable.</p>
  </li>
</ul>

<h3 id="control-structure">Control Structure</h3>

<ul>
  <li>
    <p>VALUE rb_block_call(VALUE recv, ID mid, int argc, VALUE * argv,
VALUE (*func) (ANYARGS), VALUE data2): Calls a method on the recv,
with the method name specified by the symbol mid, with argc arguments
in argv, supplying func as the block. When func is called as the
block, it will receive the value from yield as the first argument, and
data2 as the second argument. When yielded with multiple values (in C,
rb_yield_values(), rb_yield_values2() and rb_yield_splat()),
data2 is packed as an Array, whereas yielded values can be gotten via
argc/argv of the third/fourth arguments.</p>
  </li>
  <li>
    <p>[OBSOLETE] VALUE rb_iterate(VALUE (<em>func1)(), VALUE arg1, VALUE
(</em>func2)(), VALUE arg2): Calls the function func1, supplying func2 as
the block. func1 will be called with the argument arg1. func2 receives
the value from yield as the first argument, arg2 as the second
argument.</p>

    <p>When rb_iterate is used in 1.9, func1 has to call some Ruby-level
method. This function is obsolete since 1.9; use rb_block_call
instead.</p>
  </li>
  <li>
    <p>VALUE rb_yield(VALUE val): Evaluates the block with value val.</p>
  </li>
  <li>
    <p>VALUE rb_rescue(VALUE (<em>func1)(ANYARGS), VALUE arg1, VALUE
(</em>func2)(ANYARGS), VALUE arg2): Calls the function func1, with arg1 as
the argument. If an exception occurs during func1, it calls func2 with
arg2 as the first argument and the exception object as the second
argument. The return value of rb_rescue() is the return value from
func1 if no exception occurs, from func2 otherwise.</p>
  </li>
  <li>
    <p>VALUE rb_ensure(VALUE (<em>func1)(ANYARGS), VALUE arg1, VALUE
(</em>func2)(ANYARGS), VALUE arg2): Calls the function func1 with arg1 as
the argument, then calls func2 with arg2 if execution terminated. The
return value from rb_ensure() is that of func1 when no exception
occurred.</p>
  </li>
  <li>
    <p>VALUE rb_protect(VALUE (*func) (VALUE), VALUE arg, int *state):
Calls the function func with arg as the argument. If no exception
occurred during func, it returns the result of func and *state is
zero. Otherwise, it returns Qnil and sets *state to nonzero. If state
is NULL, it is not set in both cases. You have to clear the error info
with rb_set_errinfo(Qnil) when ignoring the caught exception.</p>
  </li>
  <li>
    <p>void rb_jump_tag(int state): Continues the exception caught by
rb_protect() and rb_eval_string_protect(). state must be the
returned value from those functions. This function never return to the
caller.</p>
  </li>
  <li>
    <p>void rb_iter_break(): Exits from the current innermost block. This
function never return to the caller.</p>
  </li>
  <li>
    <p>void rb_iter_break_value(VALUE value): Exits from the current
innermost block with the value. The block will return the given
argument value. This function never return to the caller.</p>
  </li>
</ul>

<h3 id="exceptions-and-errors">Exceptions and Errors</h3>

<ul>
  <li>
    <p>void rb_warn(const char *fmt, …): Prints a warning message
according to a printf-like format.</p>
  </li>
  <li>
    <p>void rb_warning(const char *fmt, …): Prints a warning message
according to a printf-like format, if $VERBOSE is true.</p>
  </li>
  <li>
    <p>void rb_raise(rb_eRuntimeError, const char *fmt, …): Raises
RuntimeError. The fmt is a format string just like printf().</p>
  </li>
  <li>
    <p>void rb_raise(VALUE exception, const char *fmt, …): Raises a class
exception. The fmt is a format string just like printf().</p>
  </li>
  <li>
    <p>void rb_fatal(const char *fmt, …): Raises a fatal error,
terminates the interpreter. No exception handling will be done for
fatal errors, but ensure blocks will be executed.</p>
  </li>
  <li>
    <p>void rb_bug(const char *fmt, …): Terminates the interpreter
immediately. This function should be called under the situation caused
by the bug in the interpreter. No exception handling nor ensure
execution will be done.</p>
  </li>
</ul>

<p>Note: In the format string, “%”PRIsVALUE can be used for <code class="highlighter-rouge">Object#to_s</code>
(or Object#inspect if ‘+’ flag is set) output (and related argument must
be a VALUE). Since it conflicts with “%i”, for integers in format
strings, use “%d”.</p>

<h3 id="threading">Threading</h3>

<p>As of Ruby 1.9, Ruby supports native 1:1 threading with one kernel
thread per Ruby Thread object. Currently, there is a GVL (Global VM
Lock) which prevents simultaneous execution of Ruby code which may be
released by the rb_thread_call_without_gvl and
rb_thread_call_without_gvl2 functions. These functions are
tricky-to-use and documented in thread.c; do not use them before reading
comments in thread.c.</p>

<ul>
  <li>void rb_thread_schedule(void): Give the scheduler a hint to pass
execution to another thread.</li>
</ul>

<h3 id="inputoutput-io-on-a-single-file-descriptor">Input/Output (IO) on a single file descriptor</h3>

<ul>
  <li>
    <p>int rb_io_wait_readable(int fd): Wait indefinitely for the given FD
to become readable, allowing other threads to be scheduled. Returns a
true value if a read may be performed, false if there is an
unrecoverable error.</p>
  </li>
  <li>
    <p>int rb_io_wait_writable(int fd): Like rb_io_wait_readable, but
for writability.</p>
  </li>
  <li>
    <p>int rb_wait_for_single_fd(int fd, int events, struct timeval
*timeout): Allows waiting on a single FD for one or multiple events
with a specified timeout.</p>

    <p><code class="highlighter-rouge">events</code> is a mask of any combination of the following values:</p>

    <ul>
      <li>RB_WAITFD_IN - wait for readability of normal data</li>
      <li>RB_WAITFD_OUT - wait for writability</li>
      <li>RB_WAITFD_PRI - wait for readability of urgent data</li>
    </ul>

    <p>Use a NULL <code class="highlighter-rouge">timeout</code> to wait indefinitely.</p>
  </li>
</ul>

<h3 id="io-multiplexing">I/O Multiplexing</h3>

<p>Ruby supports I/O multiplexing based on the select(2) system call. The
Linux select_tut(2) manpage
<a href="http://man7.org/linux/man-pages/man2/select_tut.2.html">http://man7.org/linux/man-pages/man2/select_tut.2.html</a>
provides a good overview on how to use select(2), and the Ruby API has
analogous functions and data structures to the well-known select API.
Understanding of select(2) is required to understand this section.</p>

<ul>
  <li>
    <p>typedef struct rb_fdset_t: The data structure which wraps the
fd_set bitmap used by select(2). This allows Ruby to use FD sets
larger than that allowed by historic limitations on modern platforms.</p>
  </li>
  <li>
    <p>void rb_fd_init(rb_fdset_t <em>): Initializes the rb_fdset_t, it
must be initialized before other rb_fd_</em> operations. Analogous to
calling malloc(3) to allocate an fd_set.</p>
  </li>
  <li>
    <p>void rb_fd_term(rb_fdset_t *): Destroys the rb_fdset_t,
releasing any memory and resources it used. It must be reinitialized
using rb_fd_init before future use. Analogous to calling free(3) to
release memory for an fd_set.</p>
  </li>
  <li>
    <p>void rb_fd_zero(rb_fdset_t *): Clears all FDs from the
rb_fdset_t, analogous to FD_ZERO(3).</p>
  </li>
  <li>
    <p>void rb_fd_set(int fd, rb_fdset_t *): Adds a given FD in the
rb_fdset_t, analogous to FD_SET(3).</p>
  </li>
  <li>
    <p>void rb_fd_clr(int fd, rb_fdset_t *): Removes a given FD from the
rb_fdset_t, analogous to FD_CLR(3).</p>
  </li>
  <li>
    <p>int rb_fd_isset(int fd, const rb_fdset_t *): Returns true if a
given FD is set in the rb_fdset_t, false if not. Analogous to
FD_ISSET(3).</p>
  </li>
  <li>
    <p>int rb_thread_fd_select(int nfds, rb_fdset_t *readfds,
rb_fdset_t *writefds, rb_fdset_t *exceptfds, struct timeval
*timeout): Analogous to the select(2) system call, but allows other
Ruby threads to be scheduled while waiting.</p>

    <p>When only waiting on a single FD, favor rb_io_wait_readable,
rb_io_wait_writable, or rb_wait_for_single_fd functions since
they can be optimized for specific platforms (currently, only Linux).</p>
  </li>
</ul>

<h3 id="initialize-and-start-the-interpreter">Initialize and Start the Interpreter</h3>

<p>The embedding API functions are below (not needed for extension
libraries):</p>

<ul>
  <li>
    <p>void ruby_init(): Initializes the interpreter.</p>
  </li>
  <li>
    <p>void *ruby_options(int argc, char **argv): Process command line
arguments for the interpreter. And compiles the Ruby source to
execute. It returns an opaque pointer to the compiled source or an
internal special value.</p>
  </li>
  <li>
    <p>int ruby_run_node(void *n): Runs the given compiled source and
exits this process. It returns EXIT_SUCCESS if successfully runs the
source. Otherwise, it returns other value.</p>
  </li>
  <li>
    <p>void ruby_script(char *name): Specifies the name of the script ($0).</p>
  </li>
</ul>

<h3 id="hooks-for-the-interpreter-events">Hooks for the Interpreter Events</h3>

<ul>
  <li>
    <p>void rb_add_event_hook(rb_event_hook_func_t func,
rb_event_flag_t events, VALUE data): Adds a hook function for the
specified interpreter events. events should be OR’ed value of:</p>

    <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="no">RUBY_EVENT_LINE</span>
  <span class="no">RUBY_EVENT_CLASS</span>
  <span class="no">RUBY_EVENT_END</span>
  <span class="no">RUBY_EVENT_CALL</span>
  <span class="no">RUBY_EVENT_RETURN</span>
  <span class="no">RUBY_EVENT_C_CALL</span>
  <span class="no">RUBY_EVENT_C_RETURN</span>
  <span class="no">RUBY_EVENT_RAISE</span>
  <span class="no">RUBY_EVENT_ALL</span>
</code></pre></div>    </div>

    <p>The definition of rb_event_hook_func_t is below:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  typedef void (*rb_event_hook_func_t)(rb_event_t event, VALUE data,
                                       VALUE self, ID id, VALUE klass)
</code></pre></div>    </div>

    <p>The third argument <code class="highlighter-rouge">data</code> to rb_add_event_hook() is passed to the
hook function as the second argument, which was the pointer to the
current NODE in 1.8. See RB_EVENT_HOOKS_HAVE_CALLBACK_DATA below.</p>
  </li>
  <li>
    <p>int rb_remove_event_hook(rb_event_hook_func_t func): Removes
the specified hook function.</p>
  </li>
</ul>

<h3 id="memory-usage">Memory usage</h3>

<ul>
  <li>void rb_gc_adjust_memory_usage(ssize_t diff): Adjusts the amount
of registered external memory. You can tell GC how much memory is used
by an external library by this function. Calling this function with
positive diff means the memory usage is increased; new memory block is
allocated or a block is reallocated as larger size. Calling this
function with negative diff means the memory usage is decreased; a
memory block is freed or a block is reallocated as smaller size. This
function may trigger the GC.</li>
</ul>

<h3 id="macros-for-compatibility">Macros for Compatibility</h3>

<p>Some macros to check API compatibilities are available by default.</p>

<ul>
  <li>
    <p>NORETURN_STYLE_NEW: Means that NORETURN macro is functional style
instead of prefix.</p>
  </li>
  <li>
    <p>HAVE_RB_DEFINE_ALLOC_FUNC: Means that function
rb_define_alloc_func() is provided, that means the allocation
framework is used. This is same as the result of
have_func(“rb_define_alloc_func”, “ruby.h”).</p>
  </li>
  <li>
    <p>HAVE_RB_REG_NEW_STR: Means that function rb_reg_new_str() is
provided, that creates Regexp object from String object. This is same
as the result of have_func(“rb_reg_new_str”, “ruby.h”).</p>
  </li>
  <li>
    <p>HAVE_RB_IO_T: Means that type rb_io_t is provided.</p>
  </li>
  <li>
    <p>USE_SYMBOL_AS_METHOD_NAME: Means that Symbols will be returned as
method names, e.g., <code class="highlighter-rouge">Module#methods</code>, #singleton_methods and so on.</p>
  </li>
  <li>
    <p>HAVE_RUBY_*_H: Defined in ruby.h and means corresponding header is
available. For instance, when HAVE_RUBY_ST_H is defined you should
use ruby/st.h not mere st.h.</p>
  </li>
  <li>
    <p>RB_EVENT_HOOKS_HAVE_CALLBACK_DATA: Means that
rb_add_event_hook() takes the third argument <code class="highlighter-rouge">data</code>, to be passed
to the given event hook function.</p>
  </li>
</ul>

<h2 id="appendix-c-functions-available-for-use-in-extconfrb">Appendix C. Functions available for use in extconf.rb</h2>

<p>See documentation for <a href="rdoc-ref:MakeMakefile">mkmf</a>.</p>

<h2 id="appendix-d-generational-gc">Appendix D. Generational GC</h2>

<p>Ruby 2.1 introduced a generational garbage collector (called RGenGC).
RGenGC (mostly) keeps compatibility.</p>

<p>Generally, the use of the technique called write barriers is required in
extension libraries for generational GC
(https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29).
RGenGC works fine without write barriers in extension libraries.</p>

<p>If your library adheres to the following tips, performance can be
further improved. Especially, the “Don’t touch pointers directly”
section is important.</p>

<h3 id="incompatibility">Incompatibility</h3>

<p>You can’t write RBASIC(obj)-&gt;klass field directly because it is const
value now.</p>

<p>Basically you should not write this field because MRI expects it to be
an immutable field, but if you want to do it in your extension you can
use the following functions:</p>

<ul>
  <li>
    <p>VALUE rb_obj_hide(VALUE obj): Clear RBasic::klass field. The object
will be an internal object. ObjectSpace::each_object can’t find this
object.</p>
  </li>
  <li>
    <p>VALUE rb_obj_reveal(VALUE obj, VALUE klass): Reset RBasic::klass to
be klass. We expect the <code class="highlighter-rouge">klass</code> is hidden class by rb_obj_hide().</p>
  </li>
</ul>

<h3 id="write-barriers">Write barriers</h3>

<p>RGenGC doesn’t require write barriers to support generational GC.
However, caring about write barrier can improve the performance of
RGenGC. Please check the following tips.</p>

<h4 id="dont-touch-pointers-directly">Don’t touch pointers directly</h4>

<p>In MRI (include/ruby/ruby.h), some macros to acquire pointers to the
internal data structures are supported such as RARRAY_PTR(),
RSTRUCT_PTR() and so on.</p>

<p>DO NOT USE THESE MACROS and instead use the corresponding C-APIs such as
rb_ary_aref(), rb_ary_store() and so on.</p>

<h4 id="consider-whether-to-insert-write-barriers">Consider whether to insert write barriers</h4>

<p>You don’t need to care about write barriers if you only use built-in
types.</p>

<p>If you support T_DATA objects, you may consider using write barriers.</p>

<p>Inserting write barriers into T_DATA objects only works with the
following type objects: (a) long-lived objects, (b) when a huge number
of objects are generated and (c) container-type objects that have
references to other objects. If your extension provides such a type of
T_DATA objects, consider inserting write barriers.</p>

<p>(a): short-lived objects don’t become old generation objects. (b): only
a few oldgen objects don’t have performance impact. (c): only a few
references don’t have performance impact.</p>

<p>Inserting write barriers is a very difficult hack, it is easy to
introduce critical bugs. And inserting write barriers has several areas
of overhead. Basically we don’t recommend you insert write barriers.
Please carefully consider the risks.</p>

<h4 id="combine-with-built-in-types">Combine with built-in types</h4>

<p>Please consider utilizing built-in types. Most built-in types support
write barrier, so you can use them to avoid manually inserting write
barriers.</p>

<p>For example, if your T_DATA has references to other objects, then you
can move these references to Array. A T_DATA object only has a
reference to an array object. Or you can also use a Struct object to
gather a T_DATA object (without any references) and an that Array
contains references.</p>

<p>With use of such techniques, you don’t need to insert write barriers
anymore.</p>

<h4 id="insert-write-barriers">Insert write barriers</h4>

<p>[AGAIN] Inserting write barriers is a very difficult hack, and it is
easy to introduce critical bugs. And inserting write barriers has
several areas of overhead. Basically we don’t recommend you insert write
barriers. Please carefully consider the risks.</p>

<p>Before inserting write barriers, you need to know about RGenGC algorithm
(gc.c will help you). Macros and functions to insert write barriers are
available in include/ruby/ruby.h. An example is available in iseq.c.</p>

<p>For a complete guide for RGenGC and write barriers, please refer to
<a href="https://bugs.ruby-lang.org/projects/ruby-trunk/wiki/RGenGC">https://bugs.ruby-lang.org/projects/ruby-trunk/wiki/RGenGC</a>.</p>

<h2 id="appendix-e-rb_gc_guard-to-protect-from-premature-gc">Appendix E. RB_GC_GUARD to protect from premature GC</h2>

<p>C Ruby currently uses conservative garbage collection, thus VALUE
variables must remain visible on the stack or registers to ensure any
associated data remains usable. Optimizing C compilers are not designed
with conservative garbage collection in mind, so they may optimize away
the original VALUE even if the code depends on data associated with that
VALUE.</p>

<p>The following example illustrates the use of RB_GC_GUARD to ensure the
contents of sptr remain valid while the second invocation of
rb_str_new_cstr is running.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE s, w;
const char *sptr;

s = rb_str_new_cstr("hello world!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
sptr = RSTRING_PTR(s);
w = rb_str_new_cstr(sptr + 6); /* Possible GC invocation */

RB_GC_GUARD(s); /* ensure s (and thus sptr) do not get GC-ed */
</code></pre></div></div>

<p>In the above example, RB_GC_GUARD must be placed <em>after</em> the last use
of sptr. Placing RB_GC_GUARD before dereferencing sptr would be of no
use. RB_GC_GUARD is only effective on the VALUE data type, not
converted C data types.</p>

<p>RB_GC_GUARD would not be necessary at all in the above example if
non-inlined function calls are made on the <code class="highlighter-rouge">s</code> VALUE after sptr is
dereferenced. Thus, in the above example, calling any un-inlined
function on <code class="highlighter-rouge">s</code> such as:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb_str_modify</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div>

<p>Will ensure <code class="highlighter-rouge">s</code> stays on the stack or register to prevent a GC
invocation from prematurely freeing it.</p>

<p>Using the RB_GC_GUARD macro is preferable to using the “volatile”
keyword in C. RB_GC_GUARD has the following advantages:</p>

<ol>
  <li>
    <p>the intent of the macro use is clear</p>
  </li>
  <li>
    <p>RB_GC_GUARD only affects its call site, “volatile” generates some
extra code every time the variable is used, hurting optimization.</p>
  </li>
  <li>
    <p>“volatile” implementations may be buggy/inconsistent in some
compilers and architectures. RB_GC_GUARD is customizable for
broken systems/compilers without negatively affecting other systems.</p>
  </li>
</ol>

<h2 id="makemakefile">MakeMakefile</h2>

<p>mkmf.rb is used by Ruby C extensions to generate a Makefile which will
correctly compile and link the C extension to Ruby and a third-party
library.</p>

<p><a href="https://ruby-doc.org/stdlib-2.5.0/libdoc/mkmf/rdoc/MakeMakefile.html">MakeMakefile
Reference</a></p>



                <!-- Mobile navigation buttons -->


                <!--
                    <a href="cli/cli-tool.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                 -->

            </div>



               <!--
                <a href="cli/cli-tool.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
                 -->

        </div>


        <script src="/js/book.js"></script>
    </body>
</html>
