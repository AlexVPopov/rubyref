


<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> | </title>

        <link rel="stylesheet" href="/css/style.css">
        <link rel="stylesheet" href="/css/highlight.css">
        <link rel='stylesheet' href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='/jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter">

              
              <li>
                <a href="#about-this-book.html"> About This Book</a>
              </li>
              
              <li>
                <a href="#language.html"> Language Structure</a>
              </li>
              
              <li>
                <a href="#builtin.html"> Built-in Classes</a>
              </li>
              
              <li>
                <a href="#stdlib.html"> Standard Library</a>
              </li>
              
              <li>
                <a href="#advanced-topics.html"> Advanced Topics</a>
              </li>
              

            </ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                 <h1 id="regexp">Regexp</h1>

<p>A <code class="highlighter-rouge">Regexp</code> holds a regular expression, used to match a pattern against
strings. Regexps are created using the <code class="highlighter-rouge">/.../</code> and <code class="highlighter-rouge">%r{...}</code> literals,
and by the <code class="highlighter-rouge">Regexp::new</code> constructor.</p>

<p>Regular expressions (<em>regexp</em>s) are patterns which describe the contents
of a string. They’re used for testing whether a string contains a given
pattern, or extracting the portions that match. They are created with
the <code class="highlighter-rouge">/</code><em>pat</em><code class="highlighter-rouge">/</code> and <code class="highlighter-rouge">%r{</code><em>pat</em><code class="highlighter-rouge">}</code> literals or the <code class="highlighter-rouge">Regexp.new</code>
constructor.</p>

<p>A regexp is usually delimited with forward slashes (<code class="highlighter-rouge">/</code>). For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/hay/</span> <span class="o">=~</span> <span class="s1">'haystack'</span>   <span class="c1">#=&gt; 0</span>
<span class="sr">/y/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'haystack'</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "y"&gt;</span>
</code></pre></div></div>

<p>If a string contains the pattern it is said to <em>match</em>. A literal string
matches itself.</p>

<p>Here ‘haystack’ does not contain the pattern ‘needle’, so it doesn’t
match:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/needle/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'haystack'</span><span class="p">)</span> <span class="c1">#=&gt; nil</span>
</code></pre></div></div>

<p>Here ‘haystack’ contains the pattern ‘hay’, so it matches:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/hay/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'haystack'</span><span class="p">)</span>    <span class="c1">#=&gt; #&lt;MatchData "hay"&gt;</span>
</code></pre></div></div>

<p>Specifically, <code class="highlighter-rouge">/st/</code> requires that the string contains the letter <em>s</em>
followed by the letter <em>t</em>, so it matches <em>haystack</em>, also.</p>

<h2 id="-and-regexpmatch"><code class="highlighter-rouge">=~</code> and <code class="highlighter-rouge">Regexp#match</code></h2>

<p>Pattern matching may be achieved by using <code class="highlighter-rouge">=~</code> operator or
<code class="highlighter-rouge">Regexp#match</code> method.</p>

<h3 id="-operator"><code class="highlighter-rouge">=~</code> operator</h3>

<p><code class="highlighter-rouge">=~</code> is Ruby’s basic pattern-matching operator. When one operand is a
regular expression and the other is a string then the regular expression
is used as a pattern to match against the string. (This operator is
equivalently defined by Regexp and String so the order of String and
Regexp do not matter. Other classes may have different implementations
of <code class="highlighter-rouge">=~</code>.) If a match is found, the operator returns index of first match
in string, otherwise it returns <code class="highlighter-rouge">nil</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/hay/</span> <span class="o">=~</span> <span class="s1">'haystack'</span>   <span class="c1">#=&gt; 0</span>
<span class="s1">'haystack'</span> <span class="o">=~</span> <span class="sr">/hay/</span>   <span class="c1">#=&gt; 0</span>
<span class="sr">/a/</span>   <span class="o">=~</span> <span class="s1">'haystack'</span>   <span class="c1">#=&gt; 1</span>
<span class="sr">/u/</span>   <span class="o">=~</span> <span class="s1">'haystack'</span>   <span class="c1">#=&gt; nil</span>
</code></pre></div></div>

<p>Using <code class="highlighter-rouge">=~</code> operator with a String and Regexp the <code class="highlighter-rouge">$~</code> global variable is
set after a successful match. <code class="highlighter-rouge">$~</code> holds a MatchData object.
Regexp.last_match is equivalent to <code class="highlighter-rouge">$~</code>.</p>

<h3 id="regexpmatch-method"><code class="highlighter-rouge">Regexp#match</code> method</h3>

<p>The <code class="highlighter-rouge">#match</code> method returns a MatchData object:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/st/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'haystack'</span><span class="p">)</span>   <span class="c1">#=&gt; #&lt;MatchData "st"&gt;</span>
</code></pre></div></div>

<h2 id="metacharacters-and-escapes">Metacharacters and Escapes</h2>

<p>The following are <em>metacharacters</em> <code class="highlighter-rouge">(</code>, <code class="highlighter-rouge">)</code>, <code class="highlighter-rouge">[</code>, <code class="highlighter-rouge">]</code>, <code class="highlighter-rouge">{</code>, <code class="highlighter-rouge">}</code>, <code class="highlighter-rouge">.</code>,
<code class="highlighter-rouge">?</code>, <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">*</code>. They have a specific meaning when appearing in a pattern.
To match them literally they must be backslash-escaped. To match a
backslash literally, backslash-escape it: <code class="highlighter-rouge">\\\</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/1 \+ 2 = 3\?/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'Does 1 + 2 = 3?'</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "1 + 2 = 3?"&gt;</span>
<span class="sr">/a\\\\b/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'a\\\\b'</span><span class="p">)</span>                    <span class="c1">#=&gt; #&lt;MatchData "a\\b"&gt;</span>
</code></pre></div></div>

<p>Patterns behave like double-quoted strings so can contain the same
backslash escapes.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\s\u{6771 4eac 90fd}/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Go to 東京都"</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData " 東京都"&gt;</span>
</code></pre></div></div>

<p>Arbitrary Ruby expressions can be embedded into patterns with the
<code class="highlighter-rouge">#{...}</code> construct.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">place</span> <span class="o">=</span> <span class="s2">"東京都"</span>
<span class="sr">/</span><span class="si">#{</span><span class="n">place</span><span class="si">}</span><span class="sr">/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Go to 東京都"</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData "東京都"&gt;</span>
</code></pre></div></div>

<h2 id="character-classes">Character Classes</h2>

<p>A <em>character class</em> is delimited with square brackets (<code class="highlighter-rouge">[</code>, <code class="highlighter-rouge">]</code>) and
lists characters that may appear at that point in the match. <code class="highlighter-rouge">/[ab]/</code>
means <em>a</em> or <em>b</em>, as opposed to <code class="highlighter-rouge">/ab/</code> which means <em>a</em> followed by <em>b</em>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/W[aeiou]rd/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Word"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "Word"&gt;</span>
</code></pre></div></div>

<p>Within a character class the hyphen (<code class="highlighter-rouge">-</code>) is a metacharacter denoting an
inclusive range of characters. <code class="highlighter-rouge">[abcd]</code> is equivalent to <code class="highlighter-rouge">[a-d]</code>. A
range can be followed by another range, so <code class="highlighter-rouge">[abcdwxyz]</code> is equivalent to
<code class="highlighter-rouge">[a-dw-z]</code>. The order in which ranges or individual characters appear
inside a character class is irrelevant.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/[0-9a-f]/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'9f'</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "9"&gt;</span>
<span class="sr">/[9f]/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'9f'</span><span class="p">)</span>     <span class="c1">#=&gt; #&lt;MatchData "9"&gt;</span>
</code></pre></div></div>

<p>If the first character of a character class is a caret (<code class="highlighter-rouge">^</code>) the class
is inverted: it matches any character <em>except</em> those named.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/[^a-eg-z]/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'f'</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "f"&gt;</span>
</code></pre></div></div>

<p>A character class may contain another character class. By itself this
isn’t useful because <code class="highlighter-rouge">[a-z[0-9]]</code> describes the same set as <code class="highlighter-rouge">[a-z0-9]</code>.
However, character classes also support the <code class="highlighter-rouge">&amp;&amp;</code> operator which performs
set intersection on its arguments. The two can be combined as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/[a-w&amp;&amp;[^c-g]z]/</span> <span class="c1"># ([a-w] AND ([^c-g] OR z))</span>
</code></pre></div></div>

<p>This is equivalent to:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/[abh-w]/</span>
</code></pre></div></div>

<p>The following metacharacters also behave like character classes:</p>

<ul>
  <li><code class="highlighter-rouge">/./</code> - Any character except a newline.</li>
  <li><code class="highlighter-rouge">/./m</code> - Any character (the <code class="highlighter-rouge">m</code> modifier enables multiline mode)</li>
  <li><code class="highlighter-rouge">/\w/</code> - A word character (<code class="highlighter-rouge">[a-zA-Z0-9_]</code>)</li>
  <li>
    <p><code class="highlighter-rouge">/\W/</code> - A non-word character (<code class="highlighter-rouge">[^a-zA-Z0-9_]</code>). Please take a look at
<a href="https://bugs.ruby-lang.org/issues/4044">Bug #4044</a> if using <code class="highlighter-rouge">/\W/</code>
with the <code class="highlighter-rouge">/i</code> modifier.</p>
  </li>
  <li><code class="highlighter-rouge">/\d/</code> - A digit character (<code class="highlighter-rouge">[0-9]</code>)</li>
  <li><code class="highlighter-rouge">/\D/</code> - A non-digit character (<code class="highlighter-rouge">[^0-9]</code>)</li>
  <li><code class="highlighter-rouge">/\h/</code> - A hexdigit character (<code class="highlighter-rouge">[0-9a-fA-F]</code>)</li>
  <li><code class="highlighter-rouge">/\H/</code> - A non-hexdigit character (<code class="highlighter-rouge">[^0-9a-fA-F]</code>)</li>
  <li><code class="highlighter-rouge">/\s/</code> - A whitespace character: <code class="highlighter-rouge">/[ \t\r\n\f\v]/</code></li>
  <li><code class="highlighter-rouge">/\S/</code> - A non-whitespace character: <code class="highlighter-rouge">/[^ \t\r\n\f\v]/</code></li>
</ul>

<p>POSIX <em>bracket expressions</em> are also similar to character classes. They
provide a portable alternative to the above, with the added benefit that
they encompass non-ASCII characters. For instance, <code class="highlighter-rouge">/\d/</code> matches only
the ASCII decimal digits (0-9); whereas <code class="highlighter-rouge">/[[:digit:]]/</code> matches any
character in the Unicode <em>Nd</em> category.</p>

<ul>
  <li><code class="highlighter-rouge">/[[:alnum:]]/</code> - Alphabetic and numeric character</li>
  <li><code class="highlighter-rouge">/[[:alpha:]]/</code> - Alphabetic character</li>
  <li><code class="highlighter-rouge">/[[:blank:]]/</code> - Space or tab</li>
  <li><code class="highlighter-rouge">/[[:cntrl:]]/</code> - Control character</li>
  <li><code class="highlighter-rouge">/[[:digit:]]/</code> - Digit</li>
  <li>
    <p><code class="highlighter-rouge">/[[:graph:]]/</code> - Non-blank character (excludes spaces, control
characters, and similar)</p>
  </li>
  <li><code class="highlighter-rouge">/[[:lower:]]/</code> - Lowercase alphabetical character</li>
  <li><code class="highlighter-rouge">/[[:print:]]/</code> - Like [:graph:], but includes the space character</li>
  <li><code class="highlighter-rouge">/[[:punct:]]/</code> - Punctuation character</li>
  <li>
    <p><code class="highlighter-rouge">/[[:space:]]/</code> - Whitespace character (<code class="highlighter-rouge">[:blank:]</code>, newline, carriage
return, etc.)</p>
  </li>
  <li><code class="highlighter-rouge">/[[:upper:]]/</code> - Uppercase alphabetical</li>
  <li><code class="highlighter-rouge">/[[:xdigit:]]/</code> - Digit allowed in a hexadecimal number (i.e.,
0-9a-fA-F)</li>
</ul>

<p>Ruby also supports the following non-POSIX character classes:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">/[[:word:]]/</code> - A character in one of the following Unicode general
categories <em>Letter</em>, <em>Mark</em>, <em>Number</em>, <em>Connector_Punctuation</em></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">/[[:ascii:]]/</code> - A character in the ASCII character set</p>

    <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># U+06F2 is "EXTENDED ARABIC-INDIC DIGIT TWO"</span>
<span class="sr">/[[:digit:]]/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"</span><span class="se">\u</span><span class="s2">06F2"</span><span class="p">)</span>    <span class="c1">#=&gt; #&lt;MatchData "\u{06F2}"&gt;</span>
<span class="sr">/[[:upper:]][[:lower:]]/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Hello"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "He"&gt;</span>
<span class="sr">/[[:xdigit:]][[:xdigit:]]/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"A6"</span><span class="p">)</span>  <span class="c1">#=&gt; #&lt;MatchData "A6"&gt;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="repetition">Repetition</h2>

<p>The constructs described so far match a single character. They can be
followed by a repetition metacharacter to specify how many times they
need to occur. Such metacharacters are called <em>quantifiers</em>.</p>

<ul>
  <li><code class="highlighter-rouge">*</code> - Zero or more times</li>
  <li><code class="highlighter-rouge">+</code> - One or more times</li>
  <li><code class="highlighter-rouge">?</code> - Zero or one times (optional)</li>
  <li><code class="highlighter-rouge">{</code><em>n</em><code class="highlighter-rouge">}</code> - Exactly <em>n</em> times</li>
  <li><code class="highlighter-rouge">{</code><em>n</em><code class="highlighter-rouge">,}</code> - <em>n</em> or more times</li>
  <li><code class="highlighter-rouge">{,</code><em>m</em><code class="highlighter-rouge">}</code> - <em>m</em> or less times</li>
  <li><code class="highlighter-rouge">{</code><em>n</em><code class="highlighter-rouge">,</code><em>m</em><code class="highlighter-rouge">}</code> - At least <em>n</em> and at most <em>m</em> times</li>
</ul>

<p>At least one uppercase character (‘H’), at least one lowercase character
(‘e’), two ‘l’ characters, then one ‘o’:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"Hello"</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/[[:upper:]]+[[:lower:]]+l{2}o/</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "Hello"&gt;</span>
</code></pre></div></div>

<p>Repetition is <em>greedy</em> by default: as many occurrences as possible are
matched while still allowing the overall match to succeed. By contrast,
<em>lazy</em> matching makes the minimal amount of matches necessary for
overall success. A greedy metacharacter can be made lazy by following it
with <code class="highlighter-rouge">?</code>.</p>

<p>Both patterns below match the string. The first uses a greedy quantifier
so ‘.+’ matches ‘<a><b>’; the second uses a lazy quantifier so ‘.+?’
matches ‘<a>’:</a></b></a></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/&lt;.+&gt;/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"&lt;a&gt;&lt;b&gt;"</span><span class="p">)</span>  <span class="c1">#=&gt; #&lt;MatchData "&lt;a&gt;&lt;b&gt;"&gt;</span>
<span class="sr">/&lt;.+?&gt;/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"&lt;a&gt;&lt;b&gt;"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "&lt;a&gt;"&gt;</span>
</code></pre></div></div>

<p>A quantifier followed by <code class="highlighter-rouge">+</code> matches <em>possessively</em>: once it has
matched it does not backtrack. They behave like greedy quantifiers, but
having matched they refuse to “give up” their match even if this
jeopardises the overall match.</p>

<h2 id="capturing">Capturing</h2>

<p>Parentheses can be used for <em>capturing</em>. The text enclosed by the
<em>n</em><sup>th</sup> group of parentheses can be subsequently referred to
with <em>n</em>. Within a pattern use the <em>backreference</em> <code class="highlighter-rouge">\n</code>; outside of the
pattern use <code class="highlighter-rouge">MatchData[n]</code>.</p>

<p>‘at’ is captured by the first group of parentheses, then referred to
later with <code class="highlighter-rouge">\1</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/[csh](..) [csh]\1 in/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"The cat sat in the hat"</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData "cat sat in" 1:"at"&gt;</span>
</code></pre></div></div>

<p>Regexp#match returns a MatchData object which makes the captured text
available with its <code class="highlighter-rouge">#[]</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/[csh](..) [csh]\1 in/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"The cat sat in the hat"</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#=&gt; 'at'</span>
</code></pre></div></div>

<p>Capture groups can be referred to by name when defined with the
<code class="highlighter-rouge">(?&lt;</code><em>name</em><code class="highlighter-rouge">&gt;)</code> or <code class="highlighter-rouge">(?'</code><em>name</em><code class="highlighter-rouge">')</code> constructs.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"$3.67"</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData "$3.67" dollars:"3" cents:"67"&gt;</span>
<span class="sr">/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"$3.67"</span><span class="p">)[</span><span class="ss">:dollars</span><span class="p">]</span> <span class="c1">#=&gt; "3"</span>
</code></pre></div></div>

<p>Named groups can be backreferenced with <code class="highlighter-rouge">\k&lt;</code><em>name</em><code class="highlighter-rouge">&gt;</code>, where <em>name</em> is
the group name.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/(?&lt;vowel&gt;[aeiou]).\k&lt;vowel&gt;.\k&lt;vowel&gt;/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'ototomy'</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData "ototo" vowel:"o"&gt;</span>
</code></pre></div></div>

<p><strong>Note</strong>: A regexp can’t use named backreferences and numbered
backreferences simultaneously.</p>

<p>When named capture groups are used with a literal regexp on the
left-hand side of an expression and the <code class="highlighter-rouge">=~</code> operator, the captured text
is also assigned to local variables with corresponding names.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)/</span> <span class="o">=~</span> <span class="s2">"$3.67"</span> <span class="c1">#=&gt; 0</span>
<span class="n">dollars</span> <span class="c1">#=&gt; "3"</span>
</code></pre></div></div>

<h2 id="grouping">Grouping</h2>

<p>Parentheses also <em>group</em> the terms they enclose, allowing them to be
quantified as one <em>atomic</em> whole.</p>

<p>The pattern below matches a vowel followed by 2 word characters:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/[aeiou]\w{2}/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Caenorhabditis elegans"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "aen"&gt;</span>
</code></pre></div></div>

<p>Whereas the following pattern matches a vowel followed by a word
character, twice, i.e. <code class="highlighter-rouge">[aeiou]\w[aeiou]\w</code>: ‘enor’.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/([aeiou]\w){2}/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Caenorhabditis elegans"</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData "enor" 1:"or"&gt;</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">(?:</code>…<code class="highlighter-rouge">)</code> construct provides grouping without capturing. That is,
it combines the terms it contains into an atomic whole without creating
a backreference. This benefits performance at the slight expense of
readability.</p>

<p>The first group of parentheses captures ‘n’ and the second ‘ti’. The
second group is referred to later with the backreference <code class="highlighter-rouge">\2</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/I(n)ves(ti)ga\2ons/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Investigations"</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData "Investigations" 1:"n" 2:"ti"&gt;</span>
</code></pre></div></div>

<p>The first group of parentheses is now made non-capturing with ‘?:’, so
it still matches ‘n’, but doesn’t create the backreference. Thus, the
backreference <code class="highlighter-rouge">\1</code> now refers to ‘ti’.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/I(?:n)ves(ti)ga\1ons/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Investigations"</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData "Investigations" 1:"ti"&gt;</span>
</code></pre></div></div>

<h3 id="atomic-grouping">Atomic Grouping</h3>

<p>Grouping can be made <em>atomic</em> with <code class="highlighter-rouge">(?&gt;</code><em>pat</em><code class="highlighter-rouge">)</code>. This causes the
subexpression <em>pat</em> to be matched independently of the rest of the
expression such that what it matches becomes fixed for the remainder of
the match, unless the entire subexpression must be abandoned and
subsequently revisited. In this way <em>pat</em> is treated as a non-divisible
whole. Atomic grouping is typically used to optimise patterns so as to
prevent the regular expression engine from backtracking needlessly.</p>

<p>The <code class="highlighter-rouge">"</code> in the pattern below matches the first character of the string,
then <code class="highlighter-rouge">.*</code> matches <em>Quote”</em>. This causes the overall match to fail, so
the text matched by <code class="highlighter-rouge">.*</code> is backtracked by one position, which leaves
the final character of the string available to match <code class="highlighter-rouge">"</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/".*"/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'"Quote"'</span><span class="p">)</span>     <span class="c1">#=&gt; #&lt;MatchData "\"Quote\""&gt;</span>
</code></pre></div></div>

<p>If <code class="highlighter-rouge">.*</code> is grouped atomically, it refuses to backtrack <em>Quote”</em>, even
though this means that the overall match fails</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/"(?&gt;.*)"/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'"Quote"'</span><span class="p">)</span> <span class="c1">#=&gt; nil</span>
</code></pre></div></div>

<h2 id="subexpression-calls">Subexpression Calls</h2>

<p>The <code class="highlighter-rouge">\g&lt;</code><em>name</em><code class="highlighter-rouge">&gt;</code> syntax matches the previous subexpression named
<em>name</em>, which can be a group name or number, again. This differs from
backreferences in that it re-executes the group rather than simply
trying to re-match the same text.</p>

<p>This pattern matches a <em>(</em> character and assigns it to the <code class="highlighter-rouge">paren</code>
group, tries to call that the <code class="highlighter-rouge">paren</code> sub-expression again but fails,
then matches a literal <em>)</em>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\A(?&lt;paren&gt;\(\g&lt;paren&gt;*\))*\z/</span> <span class="o">=~</span> <span class="s1">'()'</span>

<span class="sr">/\A(?&lt;paren&gt;\(\g&lt;paren&gt;*\))*\z/</span> <span class="o">=~</span> <span class="s1">'(())'</span> <span class="c1">#=&gt; 0</span>
<span class="c1"># ^1</span>
<span class="c1">#      ^2</span>
<span class="c1">#           ^3</span>
<span class="c1">#                 ^4</span>
<span class="c1">#      ^5</span>
<span class="c1">#           ^6</span>
<span class="c1">#                      ^7</span>
<span class="c1">#                       ^8</span>
<span class="c1">#                       ^9</span>
<span class="c1">#                           ^10</span>
</code></pre></div></div>

<ol>
  <li>Matches at the beginning of the string, i.e. before the first
character.</li>
  <li>Enters a named capture group called <code class="highlighter-rouge">paren</code></li>
  <li>Matches a literal <em>(</em>, the first character in the string</li>
  <li>Calls the <code class="highlighter-rouge">paren</code> group again, i.e. recurses back to the second step</li>
  <li>Re-enters the <code class="highlighter-rouge">paren</code> group</li>
  <li>Matches a literal <em>(</em>, the second character in the string</li>
  <li>Try to call <code class="highlighter-rouge">paren</code> a third time, but fail because doing so would
prevent an overall successful match</li>
  <li>Match a literal <em>)</em>, the third character in the string. Marks the
end of the second recursive call</li>
  <li>Match a literal <em>)</em>, the fourth character in the string</li>
  <li>Match the end of the string</li>
</ol>

<h2 id="alternation">Alternation</h2>

<p>The vertical bar metacharacter (<code class="highlighter-rouge">|</code>) combines two expressions into a
single one that matches either of the expressions. Each expression is an
<em>alternative</em>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\w(and|or)\w/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Feliformia"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "form" 1:"or"&gt;</span>
<span class="sr">/\w(and|or)\w/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"furandi"</span><span class="p">)</span>    <span class="c1">#=&gt; #&lt;MatchData "randi" 1:"and"&gt;</span>
<span class="sr">/\w(and|or)\w/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"dissemblance"</span><span class="p">)</span> <span class="c1">#=&gt; nil</span>
</code></pre></div></div>

<h2 id="character-properties">Character Properties</h2>

<p>The <code class="highlighter-rouge">\p{}</code> construct matches characters with the named property, much
like POSIX bracket classes.</p>

<ul>
  <li><code class="highlighter-rouge">/\p{Alnum}/</code> - Alphabetic and numeric character</li>
  <li><code class="highlighter-rouge">/\p{Alpha}/</code> - Alphabetic character</li>
  <li><code class="highlighter-rouge">/\p{Blank}/</code> - Space or tab</li>
  <li><code class="highlighter-rouge">/\p{Cntrl}/</code> - Control character</li>
  <li><code class="highlighter-rouge">/\p{Digit}/</code> - Digit</li>
  <li>
    <p><code class="highlighter-rouge">/\p{Graph}/</code> - Non-blank character (excludes spaces, control
characters, and similar)</p>
  </li>
  <li><code class="highlighter-rouge">/\p{Lower}/</code> - Lowercase alphabetical character</li>
  <li><code class="highlighter-rouge">/\p{Print}/</code> - Like <code class="highlighter-rouge">\p{Graph}</code>, but includes the space character</li>
  <li><code class="highlighter-rouge">/\p{Punct}/</code> - Punctuation character</li>
  <li>
    <p><code class="highlighter-rouge">/\p{Space}/</code> - Whitespace character (<code class="highlighter-rouge">[:blank:]</code>, newline, carriage
return, etc.)</p>
  </li>
  <li><code class="highlighter-rouge">/\p{Upper}/</code> - Uppercase alphabetical</li>
  <li><code class="highlighter-rouge">/\p{XDigit}/</code> - Digit allowed in a hexadecimal number (i.e.,
0-9a-fA-F)</li>
  <li>
    <p><code class="highlighter-rouge">/\p{Word}/</code> - A member of one of the following Unicode general
category <em>Letter</em>, <em>Mark</em>, <em>Number</em>, <em>Connector_Punctuation</em></p>
  </li>
  <li><code class="highlighter-rouge">/\p{ASCII}/</code> - A character in the ASCII character set</li>
  <li><code class="highlighter-rouge">/\p{Any}/</code> - Any Unicode character (including unassigned characters)</li>
  <li><code class="highlighter-rouge">/\p{Assigned}/</code> - An assigned character</li>
</ul>

<p>A Unicode character’s <em>General Category</em> value can also be matched with
<code class="highlighter-rouge">\p{</code><em>Ab</em><code class="highlighter-rouge">}</code> where <em>Ab</em> is the category’s abbreviation as described
below:</p>

<ul>
  <li><code class="highlighter-rouge">/\p{L}/</code> - ‘Letter’</li>
  <li><code class="highlighter-rouge">/\p{Ll}/</code> - ‘Letter: Lowercase’</li>
  <li><code class="highlighter-rouge">/\p{Lm}/</code> - ‘Letter: Mark’</li>
  <li><code class="highlighter-rouge">/\p{Lo}/</code> - ‘Letter: Other’</li>
  <li><code class="highlighter-rouge">/\p{Lt}/</code> - ‘Letter: Titlecase’</li>
  <li><code class="highlighter-rouge">/\p{Lu}/</code> - ‘Letter: Uppercase</li>
  <li><code class="highlighter-rouge">/\p{Lo}/</code> - ‘Letter: Other’</li>
  <li><code class="highlighter-rouge">/\p{M}/</code> - ‘Mark’</li>
  <li><code class="highlighter-rouge">/\p{Mn}/</code> - ‘Mark: Nonspacing’</li>
  <li><code class="highlighter-rouge">/\p{Mc}/</code> - ‘Mark: Spacing Combining’</li>
  <li><code class="highlighter-rouge">/\p{Me}/</code> - ‘Mark: Enclosing’</li>
  <li><code class="highlighter-rouge">/\p{N}/</code> - ‘Number’</li>
  <li><code class="highlighter-rouge">/\p{Nd}/</code> - ‘Number: Decimal Digit’</li>
  <li><code class="highlighter-rouge">/\p{Nl}/</code> - ‘Number: Letter’</li>
  <li><code class="highlighter-rouge">/\p{No}/</code> - ‘Number: Other’</li>
  <li><code class="highlighter-rouge">/\p{P}/</code> - ‘Punctuation’</li>
  <li><code class="highlighter-rouge">/\p{Pc}/</code> - ‘Punctuation: Connector’</li>
  <li><code class="highlighter-rouge">/\p{Pd}/</code> - ‘Punctuation: Dash’</li>
  <li><code class="highlighter-rouge">/\p{Ps}/</code> - ‘Punctuation: Open’</li>
  <li><code class="highlighter-rouge">/\p{Pe}/</code> - ‘Punctuation: Close’</li>
  <li><code class="highlighter-rouge">/\p{Pi}/</code> - ‘Punctuation: Initial Quote’</li>
  <li><code class="highlighter-rouge">/\p{Pf}/</code> - ‘Punctuation: Final Quote’</li>
  <li><code class="highlighter-rouge">/\p{Po}/</code> - ‘Punctuation: Other’</li>
  <li><code class="highlighter-rouge">/\p{S}/</code> - ‘Symbol’</li>
  <li><code class="highlighter-rouge">/\p{Sm}/</code> - ‘Symbol: Math’</li>
  <li><code class="highlighter-rouge">/\p{Sc}/</code> - ‘Symbol: Currency’</li>
  <li><code class="highlighter-rouge">/\p{Sc}/</code> - ‘Symbol: Currency’</li>
  <li><code class="highlighter-rouge">/\p{Sk}/</code> - ‘Symbol: Modifier’</li>
  <li><code class="highlighter-rouge">/\p{So}/</code> - ‘Symbol: Other’</li>
  <li><code class="highlighter-rouge">/\p{Z}/</code> - ‘Separator’</li>
  <li><code class="highlighter-rouge">/\p{Zs}/</code> - ‘Separator: Space’</li>
  <li><code class="highlighter-rouge">/\p{Zl}/</code> - ‘Separator: Line’</li>
  <li><code class="highlighter-rouge">/\p{Zp}/</code> - ‘Separator: Paragraph’</li>
  <li><code class="highlighter-rouge">/\p{C}/</code> - ‘Other’</li>
  <li><code class="highlighter-rouge">/\p{Cc}/</code> - ‘Other: Control’</li>
  <li><code class="highlighter-rouge">/\p{Cf}/</code> - ‘Other: Format’</li>
  <li><code class="highlighter-rouge">/\p{Cn}/</code> - ‘Other: Not Assigned’</li>
  <li><code class="highlighter-rouge">/\p{Co}/</code> - ‘Other: Private Use’</li>
  <li><code class="highlighter-rouge">/\p{Cs}/</code> - ‘Other: Surrogate’</li>
</ul>

<p>Lastly, <code class="highlighter-rouge">\p{}</code> matches a character’s Unicode <em>script</em>. The following
scripts are supported: <em>Arabic</em>, <em>Armenian</em>, <em>Balinese</em>, <em>Bengali</em>,
<em>Bopomofo</em>, <em>Braille</em>, <em>Buginese</em>, <em>Buhid</em>, <em>Canadian_Aboriginal</em>,
<em>Carian</em>, <em>Cham</em>, <em>Cherokee</em>, <em>Common</em>, <em>Coptic</em>, <em>Cuneiform</em>,
<em>Cypriot</em>, <em>Cyrillic</em>, <em>Deseret</em>, <em>Devanagari</em>, <em>Ethiopic</em>, <em>Georgian</em>,
<em>Glagolitic</em>, <em>Gothic</em>, <em>Greek</em>, <em>Gujarati</em>, <em>Gurmukhi</em>, <em>Han</em>,
<em>Hangul</em>, <em>Hanunoo</em>, <em>Hebrew</em>, <em>Hiragana</em>, <em>Inherited</em>, <em>Kannada</em>,
<em>Katakana</em>, <em>Kayah_Li</em>, <em>Kharoshthi</em>, <em>Khmer</em>, <em>Lao</em>, <em>Latin</em>,
<em>Lepcha</em>, <em>Limbu</em>, <em>Linear_B</em>, <em>Lycian</em>, <em>Lydian</em>, <em>Malayalam</em>,
<em>Mongolian</em>, <em>Myanmar</em>, <em>New_Tai_Lue</em>, <em>Nko</em>, <em>Ogham</em>, <em>Ol_Chiki</em>,
<em>Old_Italic</em>, <em>Old_Persian</em>, <em>Oriya</em>, <em>Osmanya</em>, <em>Phags_Pa</em>,
<em>Phoenician</em>, <em>Rejang</em>, <em>Runic</em>, <em>Saurashtra</em>, <em>Shavian</em>, <em>Sinhala</em>,
<em>Sundanese</em>, <em>Syloti_Nagri</em>, <em>Syriac</em>, <em>Tagalog</em>, <em>Tagbanwa</em>,
<em>Tai_Le</em>, <em>Tamil</em>, <em>Telugu</em>, <em>Thaana</em>, <em>Thai</em>, <em>Tibetan</em>, <em>Tifinagh</em>,
<em>Ugaritic</em>, <em>Vai</em>, and <em>Yi</em>.</p>

<p>Unicode codepoint U+06E9 is named “ARABIC PLACE OF SAJDAH” and belongs
to the Arabic script:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\p{Arabic}/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"</span><span class="se">\u</span><span class="s2">06E9"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "\u06E9"&gt;</span>
</code></pre></div></div>

<p>All character properties can be inverted by prefixing their name with a
caret (<code class="highlighter-rouge">^</code>).</p>

<p>Letter ‘A’ is not in the Unicode Ll (Letter; Lowercase) category, so
this match succeeds:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\p{^Ll}/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"A"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "A"&gt;</span>
</code></pre></div></div>

<h2 id="anchors">Anchors</h2>

<p>Anchors are metacharacter that match the zero-width positions between
characters, <em>anchoring</em> the match to a specific position.</p>

<ul>
  <li><code class="highlighter-rouge">^</code> - Matches beginning of line</li>
  <li><code class="highlighter-rouge">$</code> - Matches end of line</li>
  <li><code class="highlighter-rouge">\A</code> - Matches beginning of string.</li>
  <li>
    <p><code class="highlighter-rouge">\Z</code> - Matches end of string. If string ends with a newline, it
matches just before newline</p>
  </li>
  <li><code class="highlighter-rouge">\z</code> - Matches end of string</li>
  <li>
    <p><code class="highlighter-rouge">\G</code> - Matches first matching position:</p>

    <p>In methods like <code class="highlighter-rouge">String#gsub</code> and <code class="highlighter-rouge">String#scan</code>, it changes on each
iteration. It initially matches the beginning of subject, and in each
following iteration it matches where the last match finished.</p>

    <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"    a b c"</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/ /</span><span class="p">,</span> <span class="s1">'_'</span><span class="p">)</span>    <span class="c1">#=&gt; "____a_b_c"</span>
<span class="s2">"    a b c"</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/\G /</span><span class="p">,</span> <span class="s1">'_'</span><span class="p">)</span>  <span class="c1">#=&gt; "____a b c"</span>
</code></pre></div>    </div>

    <p>In methods like <code class="highlighter-rouge">Regexp#match</code> and <code class="highlighter-rouge">String#match</code> that take an
(optional) offset, it matches where the search begins.</p>

    <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"hello, world"</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/,/</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>    <span class="c1">#=&gt; #&lt;MatchData ","&gt;</span>
<span class="s2">"hello, world"</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/\G,/</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1">#=&gt; nil</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">\b</code> - Matches word boundaries when outside brackets; backspace (0x08)
when inside brackets</p>
  </li>
  <li><code class="highlighter-rouge">\B</code> - Matches non-word boundaries</li>
  <li>
    <p><code class="highlighter-rouge">(?=</code><em>pat</em><code class="highlighter-rouge">)</code> - <em>Positive lookahead</em> assertion: ensures that the
following characters match <em>pat</em>, but doesn’t include those characters
in the matched text</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">(?!</code><em>pat</em><code class="highlighter-rouge">)</code> - <em>Negative lookahead</em> assertion: ensures that the
following characters do not match <em>pat</em>, but doesn’t include those
characters in the matched text</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">(?&lt;=</code><em>pat</em><code class="highlighter-rouge">)</code> - <em>Positive lookbehind</em> assertion: ensures that the
preceding characters match <em>pat</em>, but doesn’t include those characters
in the matched text</p>
  </li>
  <li><code class="highlighter-rouge">(?&lt;!</code><em>pat</em><code class="highlighter-rouge">)</code> - <em>Negative lookbehind</em> assertion: ensures that the
preceding characters do not match <em>pat</em>, but doesn’t include those
characters in the matched text</li>
</ul>

<p>If a pattern isn’t anchored it can begin at any point in the string:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/real/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"surrealist"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "real"&gt;</span>
</code></pre></div></div>

<p>Anchoring the pattern to the beginning of the string forces the match to
start there. ‘real’ doesn’t occur at the beginning of the string, so now
the match fails:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\Areal/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"surrealist"</span><span class="p">)</span> <span class="c1">#=&gt; nil</span>
</code></pre></div></div>

<p>The match below fails because although ‘Demand’ contains ‘and’, the
pattern does not occur at a word boundary.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\band/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Demand"</span><span class="p">)</span>
</code></pre></div></div>

<p>Whereas in the following example ‘and’ has been anchored to a non-word
boundary so instead of matching the first ‘and’ it matches from the
fourth letter of ‘demand’ instead:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/\Band.+/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Supply and demand curve"</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "and curve"&gt;</span>
</code></pre></div></div>

<p>The pattern below uses positive lookahead and positive lookbehind to
match text appearing in tags without including the tags in the match:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/(?&lt;=&lt;b&gt;)\w+(?=&lt;\/b&gt;)/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s2">"Fortune favours the &lt;b&gt;bold&lt;/b&gt;"</span><span class="p">)</span>
    <span class="c1">#=&gt; #&lt;MatchData "bold"&gt;</span>
</code></pre></div></div>

<h2 id="options">Options</h2>

<p>The end delimiter for a regexp can be followed by one or more
single-letter options which control how the pattern can match.</p>

<ul>
  <li><code class="highlighter-rouge">/pat/i</code> - Ignore case</li>
  <li><code class="highlighter-rouge">/pat/m</code> - Treat a newline as a character matched by <code class="highlighter-rouge">.</code></li>
  <li><code class="highlighter-rouge">/pat/x</code> - Ignore whitespace and comments in the pattern</li>
  <li><code class="highlighter-rouge">/pat/o</code> - Perform <code class="highlighter-rouge">#{}</code> interpolation only once</li>
</ul>

<p><code class="highlighter-rouge">i</code>, <code class="highlighter-rouge">m</code>, and <code class="highlighter-rouge">x</code> can also be applied on the subexpression level with
the <code class="highlighter-rouge">(?</code><em>on</em><code class="highlighter-rouge">-</code><em>off</em><code class="highlighter-rouge">)</code> construct, which enables options <em>on</em>, and
disables options <em>off</em> for the expression enclosed by the parentheses.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/a(?i:b)c/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'aBc'</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "aBc"&gt;</span>
<span class="sr">/a(?i:b)c/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'abc'</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "abc"&gt;</span>
</code></pre></div></div>

<p>Options may also be used with <code class="highlighter-rouge">Regexp.new</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span> <span class="no">Regexp</span><span class="o">::</span><span class="no">IGNORECASE</span><span class="p">)</span>                     <span class="c1">#=&gt; /abc/i</span>
<span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span> <span class="no">Regexp</span><span class="o">::</span><span class="no">MULTILINE</span><span class="p">)</span>                      <span class="c1">#=&gt; /abc/m</span>
<span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"abc # Comment"</span><span class="p">,</span> <span class="no">Regexp</span><span class="o">::</span><span class="no">EXTENDED</span><span class="p">)</span>             <span class="c1">#=&gt; /abc # Comment/x</span>
<span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span> <span class="no">Regexp</span><span class="o">::</span><span class="no">IGNORECASE</span> <span class="o">|</span> <span class="no">Regexp</span><span class="o">::</span><span class="no">MULTILINE</span><span class="p">)</span> <span class="c1">#=&gt; /abc/mi</span>
</code></pre></div></div>

<h2 id="free-spacing-mode-and-comments">Free-Spacing Mode and Comments</h2>

<p>As mentioned above, the <code class="highlighter-rouge">x</code> option enables <em>free-spacing</em> mode. Literal
white space inside the pattern is ignored, and the octothorpe (<code class="highlighter-rouge">#</code>)
character introduces a comment until the end of the line. This allows
the components of the pattern to be organized in a potentially more
readable fashion.</p>

<p>A contrived pattern to match a number with optional decimal places:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float_pat</span> <span class="o">=</span> <span class="sr">/\A
    [[:digit:]]+ # 1 or more digits before the decimal point
    (\.          # Decimal point
        [[:digit:]]+ # 1 or more digits after the decimal point
    )? # The decimal point and following digits are optional
\Z/x</span>
<span class="n">float_pat</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'3.14'</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "3.14" 1:".14"&gt;</span>
</code></pre></div></div>

<p>There are a number of strategies for matching whitespace:</p>

<ul>
  <li>Use a pattern such as <code class="highlighter-rouge">\s</code> or <code class="highlighter-rouge">\p{Space}</code>.</li>
  <li>Use escaped whitespace such as <code class="highlighter-rouge">\ </code>, i.e. a space preceded by a
backslash.</li>
  <li>Use a character class such as <code class="highlighter-rouge">[ ]</code>.</li>
</ul>

<p>Comments can be included in a non-<code class="highlighter-rouge">x</code> pattern with the <code class="highlighter-rouge">(?#</code><em>comment</em><code class="highlighter-rouge">)</code>
construct, where <em>comment</em> is arbitrary text ignored by the regexp
engine.</p>

<p>Comments in regexp literals cannot include unescaped terminator
characters.</p>

<h2 id="encoding">Encoding</h2>

<p>Regular expressions are assumed to use the source encoding. This can be
overridden with one of the following modifiers.</p>

<ul>
  <li><code class="highlighter-rouge">/</code><em>pat</em><code class="highlighter-rouge">/u</code> - UTF-8</li>
  <li><code class="highlighter-rouge">/</code><em>pat</em><code class="highlighter-rouge">/e</code> - EUC-JP</li>
  <li><code class="highlighter-rouge">/</code><em>pat</em><code class="highlighter-rouge">/s</code> - Windows-31J</li>
  <li><code class="highlighter-rouge">/</code><em>pat</em><code class="highlighter-rouge">/n</code> - ASCII-8BIT</li>
</ul>

<p>A regexp can be matched against a string when they either share an
encoding, or the regexp’s encoding is <em>US-ASCII</em> and the string’s
encoding is ASCII-compatible.</p>

<p>If a match between incompatible encodings is attempted an
<code class="highlighter-rouge">Encoding::CompatibilityError</code> exception is raised.</p>

<p>The <code class="highlighter-rouge">Regexp#fixed_encoding?</code> predicate indicates whether the regexp has
a <em>fixed</em> encoding, that is one incompatible with ASCII. A regexp’s
encoding can be explicitly fixed by supplying <code class="highlighter-rouge">Regexp::FIXEDENCODING</code> as
the second argument of <code class="highlighter-rouge">Regexp.new</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">=</span> <span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"a"</span><span class="p">.</span><span class="nf">force_encoding</span><span class="p">(</span><span class="s2">"iso-8859-1"</span><span class="p">),</span><span class="no">Regexp</span><span class="o">::</span><span class="no">FIXEDENCODING</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=~</span> <span class="s2">"a</span><span class="se">\u</span><span class="s2">3042"</span>
   <span class="c1"># raises Encoding::CompatibilityError: incompatible encoding regexp match</span>
   <span class="c1">#         (ISO-8859-1 regexp with UTF-8 string)</span>
</code></pre></div></div>

<h2 id="special-global-variables">Special global variables</h2>

<p>Pattern matching sets some global variables :</p>

<ul>
  <li><code class="highlighter-rouge">$~</code> is equivalent to Regexp.last_match;</li>
  <li><code class="highlighter-rouge">$&amp;</code> contains the complete matched text;</li>
  <li><code class="highlighter-rouge">$</code>` contains string before match;</li>
  <li><code class="highlighter-rouge">$'</code> contains string after match;</li>
  <li>
    <p><code class="highlighter-rouge">$1</code>, <code class="highlighter-rouge">$2</code> and so on contain text matching first, second, etc capture
group;</p>
  </li>
  <li><code class="highlighter-rouge">$+</code> contains last capture group.</li>
</ul>

<p>Example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">=</span> <span class="sr">/s(\w{2}).*(c)/</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="s1">'haystack'</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;MatchData "stac" 1:"ta" 2:"c"&gt;</span>
<span class="vg">$~</span>                                    <span class="c1">#=&gt; #&lt;MatchData "stac" 1:"ta" 2:"c"&gt;</span>
<span class="no">Regexp</span><span class="p">.</span><span class="nf">last_match</span>                     <span class="c1">#=&gt; #&lt;MatchData "stac" 1:"ta" 2:"c"&gt;</span>

<span class="vg">$&amp;</span>      <span class="c1">#=&gt; "stac"</span>
        <span class="c1"># same as m[0]</span>
<span class="vg">$`</span>      <span class="c1">#=&gt; "hay"</span>
        <span class="c1"># same as m.pre_match</span>
<span class="vg">$'</span>      <span class="c1">#=&gt; "k"</span>
        <span class="c1"># same as m.post_match</span>
<span class="vg">$1</span>      <span class="c1">#=&gt; "ta"</span>
        <span class="c1"># same as m[1]</span>
<span class="vg">$2</span>      <span class="c1">#=&gt; "c"</span>
        <span class="c1"># same as m[2]</span>
<span class="vg">$3</span>      <span class="c1">#=&gt; nil</span>
        <span class="c1"># no third group in pattern</span>
<span class="vg">$+</span>      <span class="c1">#=&gt; "c"</span>
        <span class="c1"># same as m[-1]</span>
</code></pre></div></div>

<p>These global variables are thread-local and method-local variables.</p>

<h2 id="performance">Performance</h2>

<p>Certain pathological combinations of constructs can lead to abysmally
bad performance.</p>

<p>Consider a string of 25 <em>a</em>s, a <em>d</em>, 4 <em>a</em>s, and a <em>c</em>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="s1">'a'</span> <span class="o">*</span> <span class="mi">25</span> <span class="o">+</span> <span class="s1">'d'</span> <span class="o">+</span> <span class="s1">'a'</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">'c'</span>
<span class="c1">#=&gt; "aaaaaaaaaaaaaaaaaaaaaaaaadaaaac"</span>
</code></pre></div></div>

<p>The following patterns match instantly as you would expect:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/(b|a)/</span> <span class="o">=~</span> <span class="n">s</span> <span class="c1">#=&gt; 0</span>
<span class="sr">/(b|a+)/</span> <span class="o">=~</span> <span class="n">s</span> <span class="c1">#=&gt; 0</span>
<span class="sr">/(b|a+)*/</span> <span class="o">=~</span> <span class="n">s</span> <span class="c1">#=&gt; 0</span>
</code></pre></div></div>

<p>However, the following pattern takes appreciably longer:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/(b|a+)*c/</span> <span class="o">=~</span> <span class="n">s</span> <span class="c1">#=&gt; 26</span>
</code></pre></div></div>

<p>This happens because an atom in the regexp is quantified by both an
immediate <code class="highlighter-rouge">+</code> and an enclosing <code class="highlighter-rouge">*</code> with nothing to differentiate which
is in control of any particular character. The nondeterminism that
results produces super-linear performance. (Consult <em>Mastering Regular
Expressions</em> (3rd ed.), pp 222, by <em>Jeffery Friedl</em>, for an in-depth
analysis). This particular case can be fixed by use of atomic grouping,
which prevents the unnecessary backtracking:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">start</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="sr">/(b|a+)*c/</span> <span class="o">=~</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
   <span class="c1">#=&gt; 24.702736882</span>
<span class="p">(</span><span class="n">start</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="sr">/(?&gt;b|a+)*c/</span> <span class="o">=~</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
   <span class="c1">#=&gt; 0.000166571</span>
</code></pre></div></div>

<p>A similar case is typified by the following example, which takes
approximately 60 seconds to execute for me:</p>

<p>Match a string of 29 <em>a</em>s against a pattern of 29 optional <em>a</em>s followed
by 29 mandatory <em>a</em>s:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'a?'</span> <span class="o">*</span> <span class="mi">29</span> <span class="o">+</span> <span class="s1">'a'</span> <span class="o">*</span> <span class="mi">29</span><span class="p">)</span> <span class="o">=~</span> <span class="s1">'a'</span> <span class="o">*</span> <span class="mi">29</span>
</code></pre></div></div>

<p>The 29 optional <em>a</em>s match the string, but this prevents the 29
mandatory <em>a</em>s that follow from matching. Ruby must then backtrack
repeatedly so as to satisfy as many of the optional matches as it can
while still matching the mandatory 29. It is plain to us that none of
the optional matches can succeed, but this fact unfortunately eludes
Ruby.</p>

<p>The best way to improve performance is to significantly reduce the
amount of backtracking needed. For this case, instead of individually
matching 29 optional <em>a</em>s, a range of optional <em>a</em>s can be matched all
at once with <em>a{0,29}</em>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Regexp</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'a{0,29}'</span> <span class="o">+</span> <span class="s1">'a'</span> <span class="o">*</span> <span class="mi">29</span><span class="p">)</span> <span class="o">=~</span> <span class="s1">'a'</span> <span class="o">*</span> <span class="mi">29</span>
</code></pre></div></div>

<p><a href="http://ruby-doc.org/core-2.5.0/Regexp.html">Regexp Reference</a></p>

<h2 id="matchdata">MatchData</h2>

<p><code class="highlighter-rouge">MatchData</code> is the type of the special variable <code class="highlighter-rouge">$~</code>, and is the type of
the object returned by <code class="highlighter-rouge">Regexp#match</code> and <code class="highlighter-rouge">Regexp.last_match</code>. It
encapsulates all the results of a pattern match, results normally
accessed through the special variables <code class="highlighter-rouge">$&amp;</code>, <code class="highlighter-rouge">$'</code>, <code class="highlighter-rouge">$</code><code class="highlighter-rouge">, </code>$1<code class="highlighter-rouge">, </code>$2`,
and so on.</p>

<p><a href="http://ruby-doc.org/core-2.5.0/MatchData.html">MatchData Reference</a></p>



                <!-- Mobile navigation buttons -->


                <!--
                    <a href="cli/cli-tool.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                 -->

            </div>



               <!--
                <a href="cli/cli-tool.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
                 -->

        </div>


        <script src="js/book.js"></script>
    </body>
</html>
