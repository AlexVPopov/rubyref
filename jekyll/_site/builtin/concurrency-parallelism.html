


<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> | </title>

        <link rel="stylesheet" href="/css/style.css">
        <link rel="stylesheet" href="/css/highlight.css">
        <link rel='stylesheet' href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='/jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter">

              
              <li>
                <a href="#about-this-book.html"> About This Book</a>
              </li>
              
              <li>
                <a href="#language.html"> Language Structure</a>
              </li>
              
              <li>
                <a href="#builtin.html"> Built-in Classes</a>
              </li>
              
              <li>
                <a href="#stdlib.html"> Standard Library</a>
              </li>
              
              <li>
                <a href="#advanced-topics.html"> Advanced Topics</a>
              </li>
              

            </ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                 <h1 id="thread">Thread</h1>

<p>Threads are the Ruby implementation for a concurrent programming model.</p>

<p>Programs that require multiple threads of execution are a perfect
candidate for Ruby’s Thread class.</p>

<p>For example, we can create a new thread separate from the main thread’s
execution using ::new.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">thr</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"Whats the big deal"</span> <span class="p">}</span>
</code></pre></div></div>

<p>Then we are able to pause the execution of the main thread and allow our
new thread to finish, using <code class="highlighter-rouge">#join</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">thr</span><span class="p">.</span><span class="nf">join</span> <span class="c1">#=&gt; "Whats the big deal"</span>
</code></pre></div></div>

<p>If we don’t call <code class="highlighter-rouge">thr.join</code> before the main thread terminates, then all
other threads including <code class="highlighter-rouge">thr</code> will be killed.</p>

<p>Alternatively, you can use an array for handling multiple threads at
once, like in the following example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"Whats the big deal"</span> <span class="p">}</span>
<span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"Threads are fun!"</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div></div>

<p>After creating a few threads we wait for them all to finish
consecutively.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">threads</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">thr</span><span class="o">|</span> <span class="n">thr</span><span class="p">.</span><span class="nf">join</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="thread-initialization">Thread initialization</h3>

<p>In order to create new threads, Ruby provides ::new, ::start, and
::fork. A block must be provided with each of these methods, otherwise a
ThreadError will be raised.</p>

<p>When subclassing the Thread class, the <code class="highlighter-rouge">initialize</code> method of your
subclass will be ignored by ::start and ::fork. Otherwise, be sure to
call super in your <code class="highlighter-rouge">initialize</code> method.</p>

<h3 id="thread-termination">Thread termination</h3>

<p>For terminating threads, Ruby provides a variety of ways to do this.</p>

<p>The class method ::kill, is meant to exit a given thread:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">thr</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="no">Thread</span><span class="p">.</span><span class="nf">kill</span><span class="p">(</span><span class="n">thr</span><span class="p">)</span> <span class="c1"># sends exit() to thr</span>
</code></pre></div></div>

<p>Alternatively, you can use the instance method <code class="highlighter-rouge">#exit</code>, or any of its
aliases <code class="highlighter-rouge">#kill</code> or <code class="highlighter-rouge">#terminate</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">thr</span><span class="p">.</span><span class="nf">exit</span>
</code></pre></div></div>

<h3 id="thread-status">Thread status</h3>

<p>Ruby provides a few instance methods for querying the state of a given
thread. To get a string with the current thread’s state use <code class="highlighter-rouge">#status</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">thr</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="nb">sleep</span> <span class="p">}</span>
<span class="n">thr</span><span class="p">.</span><span class="nf">status</span> <span class="c1"># =&gt; "sleep"</span>
<span class="n">thr</span><span class="p">.</span><span class="nf">exit</span>
<span class="n">thr</span><span class="p">.</span><span class="nf">status</span> <span class="c1"># =&gt; false</span>
</code></pre></div></div>

<p>You can also use <code class="highlighter-rouge">#alive?</code> to tell if the thread is running or sleeping,
and <code class="highlighter-rouge">#stop?</code> if the thread is dead or sleeping.</p>

<h3 id="thread-variables-and-scope">Thread variables and scope</h3>

<p>Since threads are created with blocks, the same rules apply to other
Ruby blocks for variable scope. Any local variables created within this
block are accessible to only this thread.</p>

<h4 id="fiber-local-vs-thread-local">Fiber-local vs. Thread-local</h4>

<p>Each fiber has its own bucket for <code class="highlighter-rouge">Thread#[]</code> storage. When you set a
new fiber-local it is only accessible within this Fiber. To illustrate:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:foo</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"bar"</span>
  <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
    <span class="nb">p</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:foo</span><span class="p">]</span> <span class="c1"># =&gt; nil</span>
  <span class="p">}.</span><span class="nf">resume</span>
<span class="p">}.</span><span class="nf">join</span>
</code></pre></div></div>

<p>This example uses <code class="highlighter-rouge">#[]</code> for getting and <code class="highlighter-rouge">#[]=</code> for setting fiber-locals,
you can also use <code class="highlighter-rouge">#keys</code> to list the fiber-locals for a given thread and
<code class="highlighter-rouge">#key?</code> to check if a fiber-local exists.</p>

<p>When it comes to thread-locals, they are accessible within the entire
scope of the thread. Given the following example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Thread</span><span class="p">.</span><span class="nf">new</span><span class="p">{</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">thread_variable_set</span><span class="p">(</span><span class="ss">:foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nb">p</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">thread_variable_get</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span> <span class="c1"># =&gt; 1</span>
  <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span><span class="p">{</span>
    <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">thread_variable_set</span><span class="p">(</span><span class="ss">:foo</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nb">p</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">thread_variable_get</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span> <span class="c1"># =&gt; 2</span>
  <span class="p">}.</span><span class="nf">resume</span>
  <span class="nb">p</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">thread_variable_get</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span>   <span class="c1"># =&gt; 2</span>
<span class="p">}.</span><span class="nf">join</span>
</code></pre></div></div>

<p>You can see that the thread-local <code class="highlighter-rouge">:foo</code> carried over into the fiber and
was changed to <code class="highlighter-rouge">2</code> by the end of the thread.</p>

<p>This example makes use of <code class="highlighter-rouge">#thread_variable_set</code> to create new
thread-locals, and <code class="highlighter-rouge">#thread_variable_get</code> to reference them.</p>

<p>There is also <code class="highlighter-rouge">#thread_variables</code> to list all thread-locals, and
<code class="highlighter-rouge">#thread_variable?</code> to check if a given thread-local exists.</p>

<h3 id="exception-handling">Exception handling</h3>

<p>Any thread can raise an exception using the <code class="highlighter-rouge">#raise</code> instance method,
which operates similarly to <code class="highlighter-rouge">Kernel#raise</code>.</p>

<p>However, it’s important to note that an exception that occurs in any
thread except the main thread depends on <code class="highlighter-rouge">#abort_on_exception</code>. This
option is <code class="highlighter-rouge">false</code> by default, meaning that any unhandled exception will
cause the thread to terminate silently when waited on by either <code class="highlighter-rouge">#join</code>
or <code class="highlighter-rouge">#value</code>. You can change this default by either
<code class="highlighter-rouge">#abort_on_exception=</code> <code class="highlighter-rouge">true</code> or setting $DEBUG to <code class="highlighter-rouge">true</code>.</p>

<p>With the addition of the class method ::handle_interrupt, you can now
handle exceptions asynchronously with threads.</p>

<h3 id="scheduling">Scheduling</h3>

<p>Ruby provides a few ways to support scheduling threads in your program.</p>

<p>The first way is by using the class method ::stop, to put the current
running thread to sleep and schedule the execution of another thread.</p>

<p>Once a thread is asleep, you can use the instance method <code class="highlighter-rouge">#wakeup</code> to
mark your thread as eligible for scheduling.</p>

<p>You can also try ::pass, which attempts to pass execution to another
thread but is dependent on the OS whether a running thread will switch
or not. The same goes for <code class="highlighter-rouge">#priority</code>, which lets you hint to the thread
scheduler which threads you want to take precedence when passing
execution. This method is also dependent on the OS and may be ignored on
some platforms.</p>

<p><a href="http://ruby-doc.org/core-2.5.0/Thread.html">Thread Reference</a></p>

<h2 id="threadgroup">ThreadGroup</h2>

<p>ThreadGroup provides a means of keeping track of a number of threads as
a group.</p>

<p>A given Thread object can only belong to one ThreadGroup at a time;
adding a thread to a new group will remove it from any previous group.</p>

<p>Newly created threads belong to the same group as the thread from which
they were created.</p>

<p><a href="http://ruby-doc.org/core-2.5.0/ThreadGroup.html">ThreadGroup Reference</a></p>

<h2 id="mutex">Mutex</h2>

<p>Mutex implements a simple semaphore that can be used to coordinate
access to shared data from multiple concurrent threads.</p>

<p>Example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semaphore</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
  <span class="n">semaphore</span><span class="p">.</span><span class="nf">synchronize</span> <span class="p">{</span>
    <span class="c1"># access shared resource</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">b</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
  <span class="n">semaphore</span><span class="p">.</span><span class="nf">synchronize</span> <span class="p">{</span>
    <span class="c1"># access shared resource</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="http://ruby-doc.org/core-2.5.0/Mutex.html">Mutex Reference</a></p>

<h3 id="conditionvariable">ConditionVariable</h3>

<p>ConditionVariable objects augment class Mutex. Using condition
variables, it is possible to suspend while in the middle of a critical
section until a resource becomes available.</p>

<p>Example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
<span class="n">resource</span> <span class="o">=</span> <span class="no">ConditionVariable</span><span class="p">.</span><span class="nf">new</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
   <span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="p">{</span>
     <span class="c1"># Thread 'a' now needs the resource</span>
     <span class="n">resource</span><span class="p">.</span><span class="nf">wait</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
     <span class="c1"># 'a' can now have the resource</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="n">b</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
   <span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="p">{</span>
     <span class="c1"># Thread 'b' has finished using the resource</span>
     <span class="n">resource</span><span class="p">.</span><span class="nf">signal</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="http://ruby-doc.org/core-2.5.0/ConditionVariable.html">ConditionVariable
Reference</a></p>

<h2 id="queue">Queue</h2>

<p>The Queue class implements multi-producer, multi-consumer queues. It is
especially useful in threaded programming when information must be
exchanged safely between multiple threads. The Queue class implements
all the required locking semantics.</p>

<p>The class implements FIFO type of queue. In a FIFO queue, the first
tasks added are the first retrieved.</p>

<p>Example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">queue</span> <span class="o">=</span> <span class="no">Queue</span><span class="p">.</span><span class="nf">new</span>

<span class="n">producer</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
     <span class="nb">sleep</span> <span class="nb">rand</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># simulate expense</span>
     <span class="n">queue</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
     <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2"> produced"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">consumer</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
     <span class="n">value</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">pop</span>
     <span class="nb">sleep</span> <span class="nb">rand</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># simulate expense</span>
     <span class="nb">puts</span> <span class="s2">"consumed </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><a href="http://ruby-doc.org/core-2.5.0/Queue.html">Queue Reference</a></p>

<h3 id="sizedqueue">SizedQueue</h3>

<p>This class represents queues of specified size capacity. The push
operation may be blocked if the capacity is full.</p>

<p>See Queue for an example of how a SizedQueue works.</p>

<p><a href="http://ruby-doc.org/core-2.5.0/SizedQueue.html">SizedQueue Reference</a></p>



                <!-- Mobile navigation buttons -->


                <!--
                    <a href="cli/cli-tool.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                 -->

            </div>



               <!--
                <a href="cli/cli-tool.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
                 -->

        </div>


        <script src="js/book.js"></script>
    </body>
</html>
