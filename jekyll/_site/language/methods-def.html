


<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> | </title>

        <link rel="stylesheet" href="/css/style.css">
        <link rel="stylesheet" href="/css/highlight.css">
        <link rel='stylesheet' href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='/jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter">

              
              <li>
                <a href="#about-this-book.html"> About This Book</a>
              </li>
              
              <li>
                <a href="#language.html"> Language Structure</a>
              </li>
              
              <li>
                <a href="#builtin.html"> Built-in Classes</a>
              </li>
              
              <li>
                <a href="#stdlib.html"> Standard Library</a>
              </li>
              
              <li>
                <a href="#advanced-topics.html"> Advanced Topics</a>
              </li>
              

            </ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                 <h1 id="methods">Methods</h1>

<p>Methods implement the functionality of your program. Here is a simple
method definition:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">one_plus_one</span>
  <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A method definition consists of the <code class="highlighter-rouge">def</code> keyword, a method name, the
body of the method, <code class="highlighter-rouge">return</code> value and the <code class="highlighter-rouge">end</code> keyword. When called
the method will execute the body of the method. This method returns <code class="highlighter-rouge">2</code>.</p>

<p>This section only covers defining methods. See also the <a href="rdoc-ref:syntax/calling_methods.rdoc">syntax
documentation on calling methods</a>.</p>

<h2 id="method-names">Method Names</h2>

<p>Method names may be one of the operators or must start a letter or a
character with the eight bit set. It may contain letters, numbers, an
<code class="highlighter-rouge">_</code> (underscore or low line) or a character with the eight bit set. The
convention is to use underscores to separate words in a multiword method
name:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">method_name</span>
  <span class="nb">puts</span> <span class="s2">"use underscores to separate words"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Ruby programs must be written in a US-ASCII-compatible character set
such as UTF-8, ISO-8859-1 etc. In such character sets if the eight bit
is set it indicates an extended character. Ruby allows method names and
other identifiers to contain such characters. Ruby programs cannot
contain some characters like ASCII NUL (<code class="highlighter-rouge">\x00</code>).</p>

<p>The following are examples of valid Ruby methods:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hello</span>
  <span class="s2">"hello"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="err">こんにちは</span>
  <span class="nb">puts</span> <span class="s2">"means hello in Japanese"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Typically method names are US-ASCII compatible since the keys to type
them exist on all keyboards.</p>

<p>Method names may end with a <code class="highlighter-rouge">!</code> (bang or exclamation mark), a <code class="highlighter-rouge">?</code>
(question mark), or <code class="highlighter-rouge">=</code> (equals sign).</p>

<p>The bang methods (<code class="highlighter-rouge">!</code> at the end of the method name) are called and
executed just like any other method. However, by convention, a method
with an exclamation point or bang is considered dangerous. In Ruby’s
core library the dangerous method implies that when a method ends with a
bang (<code class="highlighter-rouge">!</code>), it indicates that unlike its non-bang equivalent,
permanently modifies its receiver. Almost always, the Ruby core library
will have a non-bang counterpart (method name which does NOT end with
<code class="highlighter-rouge">!</code>) of every bang method (method name which does end with <code class="highlighter-rouge">!</code>) that
does not modify the receiver. This convention is typically true for the
Ruby core library but may or may not hold true for other Ruby libraries.</p>

<p>Methods that end with a question mark by convention return boolean, but
they may not always return just <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>. Often, they will
return an object to indicate a true value (or “truthy” value).</p>

<p>Methods that end with an equals sign indicate an assignment method. For
assignment methods, the return value is ignored and the arguments are
returned instead.</p>

<p>These are method names for the various Ruby operators. Each of these
operators accepts only one argument. Following the operator is the
typical use or name of the operator. Creating an alternate meaning for
the operator may lead to confusion as the user expects plus to add
things, minus to subtract things, etc. Additionally, you cannot alter
the precedence of the operators.</p>

<ul>
  <li><code class="highlighter-rouge">+</code>: add</li>
  <li><code class="highlighter-rouge">-</code>: subtract</li>
  <li><code class="highlighter-rouge">*</code>: multiply</li>
  <li><code class="highlighter-rouge">**</code>: power</li>
  <li><code class="highlighter-rouge">/</code>: divide</li>
  <li><code class="highlighter-rouge">%</code>: modulus division, String#%</li>
  <li><code class="highlighter-rouge">&amp;</code>: AND</li>
  <li><code class="highlighter-rouge">^</code>: XOR (exclusive OR)</li>
  <li><code class="highlighter-rouge">&gt;&gt;</code>: right-shift</li>
  <li><code class="highlighter-rouge">&lt;&lt;</code>: left-shift, append</li>
  <li><code class="highlighter-rouge">==</code>: equal</li>
  <li><code class="highlighter-rouge">!=</code>: not equal</li>
  <li><code class="highlighter-rouge">===</code>: case equality. See <code class="highlighter-rouge">Object#===</code></li>
  <li><code class="highlighter-rouge">=~</code>: pattern match. (Not just for regular expressions)</li>
  <li><code class="highlighter-rouge">!~</code>: does not match</li>
  <li><code class="highlighter-rouge">&lt;=&gt;</code>: comparison aka spaceship operator. See Comparable</li>
  <li><code class="highlighter-rouge">&lt;</code>: less-than</li>
  <li><code class="highlighter-rouge">&lt;=</code>: less-than or equal</li>
  <li><code class="highlighter-rouge">&gt;</code>: greater-than</li>
  <li><code class="highlighter-rouge">&gt;=</code>: greater-than or equal</li>
</ul>

<p>To define unary methods minus, plus, tilde and not (<code class="highlighter-rouge">!</code>) follow the
operator with an <code class="highlighter-rouge">@</code> as in <code class="highlighter-rouge">+@</code> or <code class="highlighter-rouge">!@</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span>
  <span class="k">def</span> <span class="nf">-@</span>
    <span class="nb">puts</span> <span class="s2">"you inverted this object"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">obj</span> <span class="o">=</span> <span class="no">C</span><span class="p">.</span><span class="nf">new</span>

<span class="o">-</span><span class="n">obj</span> <span class="c1"># prints "you inverted this object"</span>
</code></pre></div></div>

<p>Unary methods accept zero arguments.</p>

<p>Additionally, methods for element reference and assignment may be
defined: <code class="highlighter-rouge">[]</code> and <code class="highlighter-rouge">[]=</code> respectively. Both can take one or more
arguments, and element reference can take none.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span>
  <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">obj</span> <span class="o">=</span> <span class="no">C</span><span class="p">.</span><span class="nf">new</span>

<span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>     <span class="c1"># prints "5"</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># prints "10"</span>
</code></pre></div></div>

<h2 id="return-values">Return Values</h2>

<p>By default, a method returns the last expression that was evaluated in
the body of the method. In the example above, the last (and only)
expression evaluated was the simple sum <code class="highlighter-rouge">1 + 1</code>. The <code class="highlighter-rouge">return</code> keyword
can be used to make it explicit that a method returns a value.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">one_plus_one</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It can also be used to make a method return before the last expression
is evaluated.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">two_plus_two</span>
  <span class="k">return</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># this expression is never evaluated</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Note that for assignment methods the return value will be ignored when
using the assignment syntax. Instead, the argument will be returned:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">a</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">value</span>
<span class="k">end</span>

<span class="nb">p</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># prints 5</span>
</code></pre></div></div>

<p>The actual return value will be returned when invoking the method
directly:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="nb">send</span><span class="p">(</span><span class="ss">:a</span><span class="o">=</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># prints 6</span>
</code></pre></div></div>

<h2 id="scope">Scope</h2>

<p>The standard syntax to define a method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>adds the method to a class. You can define an instance method on a
specific class with the <code class="highlighter-rouge">class</code> keyword:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span>
  <span class="k">def</span> <span class="nf">my_method</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A method may be defined on another object. You may define a “class
method” (a method that is defined on the class, not an instance of the
class) like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">my_method</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>However, this is simply a special case of a greater syntactical power in
Ruby, the ability to add methods to any object. Classes are objects, so
adding class methods is simply adding methods to the Class object.</p>

<p>The syntax for adding a method to an object is as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">greeting</span> <span class="o">=</span> <span class="s2">"Hello"</span>

<span class="k">def</span> <span class="nc">greeting</span><span class="o">.</span><span class="nf">broaden</span>
  <span class="nb">self</span> <span class="o">+</span> <span class="s2">", world!"</span>
<span class="k">end</span>

<span class="n">greeting</span><span class="p">.</span><span class="nf">broaden</span> <span class="c1"># returns "Hello, world!"</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">self</code> is a keyword referring to the current object under consideration
by the compiler, which might make the use of <code class="highlighter-rouge">self</code> in defining a class
method above a little clearer. Indeed, the example of adding a <code class="highlighter-rouge">hello</code>
method to the class <code class="highlighter-rouge">String</code> can be rewritten thus:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">String</span><span class="o">.</span><span class="nf">hello</span>
  <span class="s2">"Hello, world!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A method defined like this is called a “singleton method”. <code class="highlighter-rouge">broaden</code>
will only exist on the string instance <code class="highlighter-rouge">greeting</code>. Other strings will
not have <code class="highlighter-rouge">broaden</code>.</p>

<h2 id="overriding">Overriding</h2>

<p>When Ruby encounters the <code class="highlighter-rouge">def</code> keyword, it doesn’t consider it an error
if the method already exists: it simply redefines it. This is called
<em>overriding</em>. Rather like extending core classes, this is a potentially
dangerous ability, and should be used sparingly because it can cause
unexpected results. For example, consider this irb session:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="s2">"43"</span><span class="p">.</span><span class="nf">to_i</span>
<span class="o">=&gt;</span> <span class="mi">43</span>
<span class="o">&gt;&gt;</span> <span class="k">class</span> <span class="nc">String</span>
<span class="o">&gt;&gt;</span>   <span class="k">def</span> <span class="nf">to_i</span>
<span class="o">&gt;&gt;</span>     <span class="mi">42</span>
<span class="o">&gt;&gt;</span>   <span class="k">end</span>
<span class="o">&gt;&gt;</span> <span class="k">end</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="o">&gt;&gt;</span> <span class="s2">"43"</span><span class="p">.</span><span class="nf">to_i</span>
<span class="o">=&gt;</span> <span class="mi">42</span>
</code></pre></div></div>

<p>This will effectively sabotage any code which makes use of the method
<code class="highlighter-rouge">String#to_i</code> to parse numbers from strings.</p>

<h2 id="arguments">Arguments</h2>

<p>A method may accept arguments. The argument list follows the method
name:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div></div>

<p>When called, the user of the <code class="highlighter-rouge">add_one</code> method must provide an argument.
The argument is a local variable in the method body. The method will
then add one to this argument and return the value. If given <code class="highlighter-rouge">1</code> this
method will return <code class="highlighter-rouge">2</code>.</p>

<p>The parentheses around the arguments are optional:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_one</span> <span class="n">value</span>
  <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Multiple arguments are separated by a comma:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">end</span>
</code></pre></div></div>

<p>When called, the arguments must be provided in the exact order. In other
words, the arguments are positional.</p>

<p>Repeated argument names is syntax error. There is one exception: special
name <code class="highlighter-rouge">_</code> to designate unused argument(s).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># Syntax error</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="c1"># OK</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This is useful for redefining methods, when client code expects
particular calling convention.</p>

<h3 id="default-values">Default Values</h3>

<p>Arguments may have default values:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The default value does not need to appear first, but arguments with
defaults must be grouped together. This is ok:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_values</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This will raise a SyntaxError:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_values</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="array-decomposition">Array Decomposition</h3>

<p>You can decompose (unpack or extract values from) an Array using extra
parentheses in the arguments:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
  <span class="nb">p</span> <span class="ss">a: </span><span class="n">a</span><span class="p">,</span> <span class="ss">b: </span><span class="n">b</span>
<span class="k">end</span>

<span class="n">my_method</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</code></pre></div></div>

<p>This prints:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="ss">:a</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">}</span>
</code></pre></div></div>

<p>If the argument has extra elements in the Array they will be ignored:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
  <span class="nb">p</span> <span class="ss">a: </span><span class="n">a</span><span class="p">,</span> <span class="ss">b: </span><span class="n">b</span>
<span class="k">end</span>

<span class="n">my_method</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<p>This has the same output as above.</p>

<p>You can use a <code class="highlighter-rouge">*</code> to collect the remaining arguments. This splits an
Array into a first element and the rest:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">))</span>
  <span class="nb">p</span> <span class="ss">a: </span><span class="n">a</span><span class="p">,</span> <span class="ss">b: </span><span class="n">b</span>
<span class="k">end</span>

<span class="n">my_method</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<p>This prints:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="ss">:a</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span><span class="o">=&gt;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
</code></pre></div></div>

<p>The argument will be decomposed if it responds to <code class="highlighter-rouge">#to_ary</code>. You should
only define <code class="highlighter-rouge">#to_ary</code> if you can use your object in place of an Array.</p>

<p>Use of the inner parentheses only uses one of the sent arguments. If the
argument is not an Array it will be assigned to the first argument in
the decomposition and the remaining arguments in the decomposition will
be <code class="highlighter-rouge">nil</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span>
  <span class="nb">p</span> <span class="ss">a: </span><span class="n">a</span><span class="p">,</span> <span class="ss">b: </span><span class="n">b</span><span class="p">,</span> <span class="ss">c: </span><span class="n">c</span><span class="p">,</span> <span class="ss">d: </span><span class="n">d</span>
<span class="k">end</span>

<span class="n">my_method</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p>This prints:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="ss">:a</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="ss">:c</span><span class="o">=&gt;</span><span class="kp">nil</span><span class="p">,</span> <span class="ss">:d</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

<p>You can nest decomposition arbitrarily:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span><span class="p">(((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="arrayhash-argument">Array/Hash Argument</h3>

<p>Prefixing an argument with <code class="highlighter-rouge">*</code> causes any remaining arguments to be
converted to an Array:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gather_arguments</span><span class="p">(</span><span class="o">*</span><span class="n">arguments</span><span class="p">)</span>
  <span class="nb">p</span> <span class="n">arguments</span>
<span class="k">end</span>

<span class="n">gather_arguments</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="c1"># prints [1, 2, 3]</span>
</code></pre></div></div>

<p>The array argument must be the last positional argument, it must appear
before any keyword arguments.</p>

<p>The array argument will capture a Hash as the last entry if a hash was
sent by the caller after all positional arguments.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gather_arguments</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">a: </span><span class="mi">2</span> <span class="c1"># prints [1, {:a=&gt;2}]</span>
</code></pre></div></div>

<p>However, this only occurs if the method does not declare any keyword
arguments.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gather_arguments_keyword</span><span class="p">(</span><span class="o">*</span><span class="n">positional</span><span class="p">,</span> <span class="ss">keyword: </span><span class="kp">nil</span><span class="p">)</span>
 <span class="nb">p</span> <span class="ss">positional: </span><span class="n">positional</span><span class="p">,</span> <span class="ss">keyword: </span><span class="n">keyword</span>
<span class="k">end</span>

<span class="n">gather_arguments_keyword</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">three: </span><span class="mi">3</span>
<span class="c1">#=&gt; raises: unknown keyword: three (ArgumentError)</span>
</code></pre></div></div>

<p>Also, note that a bare <code class="highlighter-rouge">*</code> can be used to ignore arguments:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ignore_arguments</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="keyword-arguments">Keyword Arguments</h3>

<p>Keyword arguments are similar to positional arguments with default
values:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_values</span><span class="p">(</span><span class="ss">first: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">second: </span><span class="mi">2</span><span class="p">)</span>
  <span class="n">first</span> <span class="o">+</span> <span class="n">second</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Arbitrary keyword arguments will be accepted with <code class="highlighter-rouge">**</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gather_arguments</span><span class="p">(</span><span class="ss">first: </span><span class="kp">nil</span><span class="p">,</span> <span class="o">**</span><span class="n">rest</span><span class="p">)</span>
  <span class="nb">p</span> <span class="n">first</span><span class="p">,</span> <span class="n">rest</span>
<span class="k">end</span>

<span class="n">gather_arguments</span> <span class="ss">first: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">second: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">third: </span><span class="mi">3</span>
<span class="c1"># prints 1 then {:second=&gt;2, :third=&gt;3}</span>
</code></pre></div></div>

<p>When calling a method with keyword arguments the arguments may appear in
any order. If an unknown keyword argument is sent by the caller an
ArgumentError is raised.</p>

<p>When mixing keyword arguments and positional arguments, all positional
arguments must appear before any keyword arguments.</p>

<p>It is possible to define keyword argument with name that is not
acceptable for variable name, like <code class="highlighter-rouge">class</code> or <code class="highlighter-rouge">next</code> (keywords). In this
case, argument’s value can be obtained via
<a href="/builtin/core.html#binding">Binding</a>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">html_tag</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="k">class</span><span class="p">:)</span>
  <span class="c1"># Will fail with SyntaxError</span>
  <span class="c1"># puts class</span>

  <span class="c1"># Works</span>
  <span class="nb">puts</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">local_variable_get</span><span class="p">(</span><span class="s1">'class'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="block-argument">Block Argument</h2>

<p>The block argument is indicated by <code class="highlighter-rouge">&amp;</code> and must come last:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_block</span><span class="p">)</span>
  <span class="n">my_block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Most frequently the block argument is used to pass a block to another
method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">each_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@items</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you are only going to call the block and will not otherwise
manipulate it or send it to another method using <code class="highlighter-rouge">yield</code> without an
explicit block parameter is preferred. This method is equivalent to the
first method in this section:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span>
  <span class="k">yield</span> <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>There is also a performance benefit to using yield over a calling a
block parameter. When a block argument is assigned to a variable a Proc
object is created which holds the block. When using yield this Proc
object is not created.</p>

<p>If you only need to use the block sometimes you can use Proc.new to
create a proc from the block that was passed to your method. See
Proc.new for further details.</p>

<h2 id="exception-handling">Exception Handling</h2>

<p>Methods have an implied exception handling block so you do not need to
use <code class="highlighter-rouge">begin</code> or <code class="highlighter-rouge">end</code> to handle exceptions. This:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span>
  <span class="k">begin</span>
    <span class="c1"># code that may raise an exception</span>
  <span class="k">rescue</span>
    <span class="c1"># handle exception</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>May be written as:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span>
  <span class="c1"># code that may raise an exception</span>
<span class="k">rescue</span>
  <span class="c1"># handle exception</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you wish to rescue an exception for only part of your method, use
<code class="highlighter-rouge">begin</code> and <code class="highlighter-rouge">end</code>. For more details see the page on <a href="rdoc-ref:syntax/exceptions.rdoc">exception
handling</a>.</p>

<h2 id="method-definition-as-an-expression">Method definition as an expression</h2>

<p><code class="highlighter-rouge">def</code> (method definition) is an <em>expression</em> returning the name of the
defined method. This fact is mostly useful for method decoration:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Ruby's standard visibility statement</span>
<span class="kp">private</span> <span class="k">def</span> <span class="nf">some_private_method</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="c1"># Decorating with third-party library for memoizing (caching) method value</span>
<span class="n">memoize</span> <span class="k">def</span> <span class="nf">some_expensive_method</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Both <code class="highlighter-rouge">private</code> and <code class="highlighter-rouge">memoize</code> above are just a method calls, receiving
result of <code class="highlighter-rouge">def</code> (method name to make private/cached) as their argument.</p>

<h3 id="alias"><code class="highlighter-rouge">alias</code></h3>

<p>The <code class="highlighter-rouge">alias</code> keyword is most frequently used to alias methods. When
aliasing a method, you can use either its name or a symbol:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">alias</span> <span class="n">new_name</span> <span class="n">old_name</span>
<span class="k">alias</span> <span class="ss">:new_name</span> <span class="ss">:old_name</span>
</code></pre></div></div>

<p>For methods, <code class="highlighter-rouge">Module#alias_method</code> can often be used instead of <code class="highlighter-rouge">alias</code>.</p>

<p>You can also use <code class="highlighter-rouge">alias</code> to alias global variables:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$old</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">alias</span> <span class="vg">$new</span> <span class="vg">$old</span>

<span class="nb">p</span> <span class="vg">$new</span> <span class="c1"># prints 0</span>
</code></pre></div></div>

<p>You may use <code class="highlighter-rouge">alias</code> in any scope.</p>

<h3 id="undef"><code class="highlighter-rouge">undef</code></h3>

<p>The <code class="highlighter-rouge">undef</code> keyword prevents the current class from responding to calls
to the named methods.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">undef</span> <span class="n">my_method</span>
</code></pre></div></div>

<p>You may use symbols instead of method names:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">undef</span> <span class="ss">:my_method</span>
</code></pre></div></div>

<p>You may undef multiple methods:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">undef</span> <span class="n">method1</span><span class="p">,</span> <span class="n">method2</span>
</code></pre></div></div>

<p>You may use <code class="highlighter-rouge">undef</code> in any scope. See also <code class="highlighter-rouge">Module#undef_method</code></p>



                <!-- Mobile navigation buttons -->


                <!--
                    <a href="cli/cli-tool.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                 -->

            </div>



               <!--
                <a href="cli/cli-tool.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
                 -->

        </div>


        <script src="js/book.js"></script>
    </body>
</html>
